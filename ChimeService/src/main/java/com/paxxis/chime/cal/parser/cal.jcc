/*
 * Copyright 2010 Robert Englander
 * Copyright 2009 Paxxis Technology LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The CAL rule parser is used to parse rules into
 * a Rule Set. This file is processed using JavaCC.
 */
PARSER_BEGIN(CALRuleParser)

package com.paxxis.chime.cal.parser;

import java.io.*;
import java.util.*;
import com.paxxis.chime.client.common.cal.*;

/**
* This is the parser class.  Most of the code for
* the parser is generated by the grammar definition.
*/
public class CALRuleParser
{
    // we generate a static parser, so we keep
    // a singleton instance.
    protected static CALRuleParser _parser = null;
    protected static String _sourceCode = null;

    public static CALRuleParser create(String contents)
    {
        // save the most recent contents
        _sourceCode = contents;

        StringReader rdr = new StringReader(contents);

        if (_parser == null)
        {
            _parser = new CALRuleParser(rdr);
        }
        else
        {
            _parser.ReInit(rdr);
        }

        return _parser;
    }

    public static CALRuleParser create(String fileName, String ruleSetName)
    {
        // read the rule contents into a String
        RuleReader ruleReader = new RuleReader();
        String contents = ruleReader.getFileContents(fileName);

        // add the custom rules to the base rules
        String fullContents = contents; // + "\n\n" + CustomRulesReader.getContents(ruleSetName);

        // save the most recent contents
        _sourceCode = fullContents;

        StringReader rdr = new StringReader(fullContents);

        if (_parser == null)
        {
            _parser = new CALRuleParser(rdr);
        }
        else
        {
            _parser.ReInit(rdr);
        }

        return _parser;
    }

    public static String getSourceCode()
    {
        return _sourceCode;
    }
}

PARSER_END(CALRuleParser)

SPECIAL_TOKEN :
{
   < WHITESPACE: (" " | "\t" | "\n" | "\r") >
}

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
  |
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN :
{
   < SINGLEQUOTE: ("'") >
|  < DOUBLEQUOTE: ("\"") >
|  < LBRACE: ("{") >
|  < RBRACE: ("}") >
|  < LPAREN: ("(") >
|  < RPAREN: (")") >
|  < LBRACKET: ("[") >
|  < RBRACKET: ("]") >
|  < ASSIGNMENT: ("=") >
|  < PLUS: ("+") >
|  < MINUS: ("-") >
|  < MULT: ("*") >
|  < DIV: ("/") >
|  < COMMA: (",") >
|  < EQUALS: ("==") >
|  < NOTEQUALS: ("!=") >
|  < STREQUALS: ("equals" | "EQUALS") >
|  < STRCAT: ("|") >
|  < GREATERTHAN: (">") >
|  < LESSTHAN: ("<") >
|  < GREATERTHANEQ: (">=") >
|  < LESSTHANEQ: ("<=") >
|  < DO: ("DO" | "do") >
|  < WHEN: ("WHEN" | "when") >
|  < SET: ("set" | "SET") >
|  < TO: ("to" | "TO") >
|  < RULE: ("rule" | "Rule" | "RULE") >
|  < SWITCH: ("switch" | "SWITCH") >
|  < CASE: ("case" | "CASE") >
|  < EVENT: ("event" | "EVENT") >
|  < TIMER: ("timer" | "TIMER") >
|  < DEFCASE: ("default" | "DEFAULT") >
|  < CONDITION: ("condition" | "CONDITION") >
|  < CHANGES: ("changes" | "CHANGES") >
|  < RETURNS: ("returns" | "RETURNS") >
|  < RETURN: ("return" | "RETURN") >
|  < TRUE: ("true" | "TRUE") >
|  < FALSE: ("false" | "FALSE") >
|  < REFERENCE: ("Reference") >
|  < VARIABLE: ("variable" | "VARIABLE") >
|  < START: ("start" | "START") >
|  < SUBMIT: ("submit" | "SUBMIT") >
|  < DURABLE: ("durable" | "DURABLE") >
|  < DYNAMIC: ("dynamic" | "DYNAMIC") >
|  < AS: ("as" | "AS") >
|  < ON: ("on" | "ON") >
|  < IF: ("if" | "IF") >
|  < ELSE: ("else" | "ELSE") >
|  < ELSEIF: ("elseif" | "ELSEIF") >
|  < WHILE: ("while" | "WHILE") >
|  < BREAK: ("break" | "BREAK") >
|  < ERROR: ("error" | "ERROR") >
|  < METHODSEP: (":") >
|  < VALUESEP: ("::") >
|  < IS: ("is" | "IS" | "are" | "ARE") >
|  < AND: ("and" | "AND") >
|  < OR: ("or" | "OR") >
|  < NOT: ("not" | "NOT") >
|  < WAIT: ("wait" | "WAIT") >
|  < UNTIL: ("until" | "UNTIL") >
|  < ARRAY: ("Array") >
|  < TABLE: ("Table") >
|  < INTEGER: ("Integer") >
|  < DOUBLE: ("Double") >
|  < BOOLEAN: ("Boolean") >
|  < STRING: ("String") >
|  < DATE: ("Date") >
|  < STOCKSYMBOL: ("StockSymbol") >
|  < DATAINSTANCE: ("DataInstance") >
|  < SHAPE: ("Shape") >
|  < EXTENSION: ("Extension") >
|  < QUERY: ("Query") >
|  < NARROW: ("narrow" | "NARROW") >
|  < WHERE: ("where" | "WHERE") >
|  < RATING: ("rating" | "RATING") >
|  < FIELD: ("field" | "FIELD") >
|  < PRINT: ("print" | "PRINT") >
|  < NEWLINE: ("newLine") >
|  < name: (["a"-"z","A"-"Z","$","@","_","."]) (["a"-"z","A"-"Z",".","_","$","@","?","&","0"-"9","\\"])* >
|  < INTEGERLITERAL: ("-")? (["0"-"9"])+ >
|  < DATELITERAL: (<INTEGERLITERAL> "/" <INTEGERLITERAL> "/" <INTEGERLITERAL>)  >
|  < FLOATLITERAL: (["0"-"9"])+ "." (["0"-"9"])+ >
}

void parseRuleSet(RuleSet ruleSet) :
{
    Rule rule;
}
{
    (rule = parseRule(ruleSet)
    {
        try
        {
            ruleSet.addRule(rule);
        }
        catch (Exception rce)
        {
            throw new ParseException(rce.getMessage());
        }
    }
    )+
}

Rule parseRule(RuleSet ruleSet) :
{
    Rule theRule = new Rule(ruleSet);
}
{
  rule(theRule)
  {
    return theRule;
  }
}

void rule(Rule theRule) :
{
    RuleVariable returnVariable = new StringVariable("#return") ;
}
{
  (
    returnVariable = returnType()
  )?
  {
     theRule.setReturnValue(returnVariable);
  }
  ruleName(theRule)
  "(" (ruleParams(theRule))? ")"
  <LBRACE>
  (<WHEN> ":" whenClauses(theRule))?
  doClauses(theRule, theRule.getQueue())
  (<ON> <ERROR> ":" doClauses(theRule, theRule.getErrorQueue()))?
  <RBRACE>
}

RuleVariable returnType() :
{}
{
    <STRING> { return new StringVariable("#return"); }
    |
    <DOUBLE> { return new DoubleVariable("#return"); }
    |
    <BOOLEAN> { return new BooleanVariable("#return"); }
    |
    <INTEGER> { return new IntegerVariable("#return"); }
    |
    <DATE> { return new DateVariable("#return"); }
    |
    <ARRAY> { return new Array("#return"); }
    |
    <TABLE> { return new Table("#return"); }
    |
    <QUERY> { return new Query("#return"); }
    |
    <DATAINSTANCE> { return new InstanceVariable("#return"); }
    |
    <SHAPE> { return new ShapeVariable("#return"); }
    |
    <EXTENSION> { return new Extension("#return"); }
    |
    <STOCKSYMBOL> { return new StockSymbol("#return"); }
}

void ruleParams(Rule theRule) :
{}
{
   ruleParam(theRule) ("," ruleParam(theRule))*
}

void ruleParam(Rule theRule) :
{
    Token tname;
    RuleVariable param;
}
{
    param = parameter()
    {
        try
        {
            theRule.getQueue().addParameter(param);
        }
        catch (RuleCreationException e)
        {
            Token tt = getToken(0);
            StringBuffer buf = new StringBuffer(e.getMessage());
            buf.append("\nRule: " + theRule.getName() + "\nLine " + tt.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buf.toString());
        }
    }
}

RuleVariable parameter() :
{
    Token t;
}
{
    <STRING> t = variablename()
    { return new StringVariable(t.image); }
    |
    <DOUBLE> t = variablename()
    { return new DoubleVariable(t.image); }
    |
    <INTEGER> t = variablename()
    { return new IntegerVariable(t.image); }
    |
    <DATE> t = variablename()
    { return new DateVariable(t.image); }
    |
    <BOOLEAN> t = variablename()
    { return new BooleanVariable(t.image); }
    |
    <ARRAY> t = variablename()
    { return new Array(t.image); }
    |
    <TABLE> t = variablename()
    { return new Table(t.image); }
    |
    <QUERY> t = variablename()
    { return new Query(t.image); }
    |
    <DATAINSTANCE> t = variablename()
    { return new InstanceVariable(t.image); }
    |
    <SHAPE> t = variablename()
    { return new ShapeVariable(t.image); }
    |
    <EXTENSION> t = variablename()
    { return new Extension(t.image); }
    |
    <STOCKSYMBOL> t = variablename()
    { return new StockSymbol(t.image); }
}

Token variablename() :
{
    Token t;
}
{
    t = <name>
    {
        return t;
    }
}

void doClauses(Rule theRule, InstructionQueue queue) :
{}
{
   (LOOKAHEAD(2) doClause(theRule, queue))*
}

void doClause(Rule theRule, InstructionQueue queue) :
{
}
{
   LOOKAHEAD(3) nullObjectOperation(queue) ";"
   |
   LOOKAHEAD(2) defineVariableClause(queue) ";"
   |
   returnClause(theRule) ";"
   |
   LOOKAHEAD(3) setVariableClause(queue) ";"
   |
   switchClause(theRule, queue)
   |
   ifClause(theRule, queue)
   |
   whileClause(theRule, queue)
   |
   breakClause(queue) ";"
   |
   printClause(queue) ";"
   |
   queryClause(queue) ";"
   |
   LOOKAHEAD(2) valueExpression(queue) ";"
}

void nullObjectOperation(InstructionQueue queue) :
{
    IValue v;
}
{
    v = objectOperation(queue)
    {
        EvaluationInstruction ei = new EvaluationInstruction(v);
        ei.setLineNumber(token.beginLine);
        queue.addInstruction(ei);
    }
}

void queryClause(InstructionQueue queue) :
{
    Token t = null;
}
{
    <NARROW> t = variablename() <WHERE>
    (
        narrowByFieldValueClause(queue, t)
        |
        narrowByRatingClause(queue, t)
    )
}

void narrowByFieldValueClause(InstructionQueue queue, Token t) :
{
    ValueExpression.Operator operator;
    IValue exp;
    IValue exp2;
}
{
    <LBRACE> exp = valueExpression(queue) <RBRACE>
    <IS>
    {
        operator = ValueExpression.Operator.VALEQUALS;
    }
    (
        LOOKAHEAD(2) <NOT>
        {
            operator = ValueExpression.Operator.NOTEQUALS;
        }
    )?
    exp2 = valueExpression(queue)
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            throw new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        if (!(rv instanceof Query))
        {
            throw new ParseException("Attempt to narrow non Query variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        Query query = (Query)rv;
        query.addParameter(new QueryParameter(QueryParameter.Narrow.ReferenceField, operator, exp, exp2));
    }
}

void narrowByRatingClause(InstructionQueue queue, Token t) :
{
    ValueExpression.Operator operator;
    IValue exp;
}
{
    <RATING>
    (
        <EQUALS> { operator = ValueExpression.Operator.VALEQUALS; }
        |
        <GREATERTHAN> { operator = ValueExpression.Operator.GREATERTHAN; }
        |
        <LESSTHAN> { operator = ValueExpression.Operator.LESSTHAN; }
        |
        <GREATERTHANEQ> { operator = ValueExpression.Operator.GREATERTHANEQ; }
        |
        <LESSTHANEQ> { operator = ValueExpression.Operator.LESSTHANEQ; }
        |
        <NOTEQUALS> { operator = ValueExpression.Operator.NOTEQUALS; }
    )
    exp = valueExpression(queue)
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            throw new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        if (!(rv instanceof Query))
        {
            throw new ParseException("Attempt to narrow non Query variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        Query query = (Query)rv;
        query.addParameter(new QueryParameter(QueryParameter.Narrow.Rating, operator, exp));
    }
}

void printClause(InstructionQueue queue) :
{
    IValue v;
}
{
    <PRINT> v = valueExpression(queue)
    {
        PrintInstruction pi = new PrintInstruction(v);
        pi.setLineNumber(token.beginLine);
        queue.addInstruction(pi);
    }
}

void returnClause(Rule theRule) :
{
    IValue v;
}
{
    <RETURN>
    (
        v = valueExpression(theRule.getQueue())
    )
    {
        ReturnInstruction ri = new ReturnInstruction();
        try
        {
            ri.setValue(theRule, v);
        }
        catch (RuleCreationException rce)
        {
            StringBuffer buffer = new StringBuffer(rce.getMessage());
            buffer.append("\nLine " + token.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buffer.toString());
        }
        ri.setLineNumber(token.beginLine);
        theRule.getQueue().addInstruction(ri);
    }
}

void breakClause(InstructionQueue queue) :
{}
{
    <BREAK>
    {
        BreakInstruction bi = new BreakInstruction();
        bi.setLineNumber(token.beginLine);
        queue.addInstruction(bi);
    }
}

void defineVariableClause(InstructionQueue queue) :
{
    RuleVariable var = null;
    SetInstruction si;
    IValue v = null;
    Token t;
    boolean durable = false;
    boolean dynamic = false;
}
{
    ( 
        <DURABLE>
        { durable = true; }
    )?
    ( 
        <DYNAMIC>
        { dynamic = true; }
    )?
    (
        LOOKAHEAD(2) var = parameter()
        |
        <ARRAY> <LPAREN> (v = valueExpression(queue))? <RPAREN> t = variablename()
        {
            var = new Array(t.image);
            CreateArrayInstruction cai = new CreateArrayInstruction(t.image, v);
            cai.setLineNumber(token.beginLine);
            queue.addInstruction(cai);
        }
        |
        <TABLE> t = variablename()
        {
            var = new Table(t.image);
            CreateTableInstruction cti = new CreateTableInstruction(t.image);
            cti.setLineNumber(token.beginLine);
            queue.addInstruction(cti);
        }
        |
        <RULE> t = variablename()
        {
            var = new RuleAccessor(t.image, queue);
        }
        |
        <REFERENCE> t = variablename()
        {
            var = new ReferenceVariable(t.image);
        }
    )
    {
        try
        {
            queue.addVariable(var);
            var.setDurable(durable);
            var.setDynamic(dynamic);
        }
        catch (RuleCreationException e)
        {
            Token tt = getToken(0);
            StringBuffer buf = new StringBuffer(e.getMessage());
            buf.append("\nLine " + tt.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buf.toString());
        }
    }
    (
        <ASSIGNMENT>
        {
            si = new SetInstruction();
            si.addVariable(var);
        }
        v = valueExpression(queue)
        {
            si.setValue(v);
            si.setLineNumber(token.beginLine);
            queue.addInstruction(si);
        }
    )?
}

void switchClause(Rule theRule, InstructionQueue queue) :
{
    SwitchInstruction inst = new SwitchInstruction(queue);
    IValue v;
    String s;
    int _firstLine;
}
{
    <SWITCH>
    { _firstLine = token.beginLine; }
    (<STRING> { inst.setStringMatching(true); } )?
    <LPAREN>
    v = valueExpression(queue) { inst.setValue(v); }
    <RPAREN>
    <LBRACE>
    (
      <CASE>
      {
         InstructionQueue q = new InstructionQueue();
         q.setParent(queue);
      }
      s = constant() ":"
      doClauses(theRule, q)
      {
         inst.addCase(s, q);
      }
    )+
    (
      <DEFCASE> ":"
      {
         InstructionQueue q = new InstructionQueue();
         q.setParent(queue);
      }
      doClauses(theRule, q) { inst.setDefaultCase(q); }
    )?
    <RBRACE>
    {
        inst.setLineNumber(_firstLine);
        queue.addInstruction(inst);
    }
}

void whileClause(Rule theRule, InstructionQueue queue) :
{
    IValue condition;
    WhileInstruction wi;
}
{
    <WHILE> <LPAREN> condition = valueExpression(queue) <RPAREN>
    {
        wi = new WhileInstruction(queue);
        wi.getBlock().setParent(queue);
        wi.setCondition(condition);
        wi.setLineNumber(token.beginLine);
        queue.addInstruction(wi);
    }
    <LBRACE>
    doClauses(theRule, wi.getBlock())
    <RBRACE>
}

void ifClause(Rule theRule, InstructionQueue queue) :
{
    IValue condition;
    IfInstruction ii = new IfInstruction(queue);
    InstructionQueue q;
}
{
    <IF> <LPAREN> condition = valueExpression(queue) <RPAREN>
    {
        ii.setCondition(condition);
        ii.setLineNumber(token.beginLine);
        queue.addInstruction(ii);
        ii.getIfBlock().setParent(queue);
    }
    <LBRACE>
    doClauses(theRule, ii.getIfBlock())
    <RBRACE>
    (
       LOOKAHEAD(2) <ELSE> <IF> <LPAREN> condition = valueExpression(queue) <RPAREN>
       <LBRACE>
       {
           q = ii.addElseIfBlock(condition);
           q.setParent(queue);
       }
       doClauses(theRule, q)
       <RBRACE>
    )*
    (
       <ELSE> <LBRACE>
       { ii.getElseBlock().setParent(queue); }
       doClauses(theRule, ii.getElseBlock())
       <RBRACE>
    )?
}

void setVariableClause(InstructionQueue queue) :
{
    SetInstruction instr = new SetInstruction();
    IValue v;
}
{
    (
       (
          setvariables(queue, instr)
          <ASSIGNMENT>
          v = valueExpression(queue)
          {
             instr.setValue(v);
          }
       )
       |
       (
          <SET> <TO>
          v = valueExpression(queue)
          {
             instr.setValue(v);
          }
          ":" setvariables(queue, instr)
       )
    )
    {
        instr.setLineNumber(token.beginLine);
        queue.addInstruction(instr);
    }
}

void setvariables(InstructionQueue queue, SetInstruction instr) :
{}
{
   setvariable(queue, instr) ("," setvariable(queue, instr))*
}

void setvariable(InstructionQueue queue, SetInstruction instr) :
{
    Token t;
    IValue v = null;
    IValue v2 = null;
    boolean isArray = false;
    boolean isTable = false;
}
{
    t = <name>
    (
        LOOKAHEAD(3)
        (
            <LBRACKET> v = valueExpression(queue) <RBRACKET>
            {
               isArray = true;
            }
        )
        |
        (
            <LBRACKET> v = valueExpression(queue) <COMMA> v2 = valueExpression(queue) <RBRACKET>
            {
               isTable = true;
            }
        )
    )?
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            throw new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        if (isArray)
        {
            if (!rv.isArray())
            {
                throw new ParseException("Attempt to index non array variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new ArrayIndexer(queue, (Array)rv, v);
        }
        else if (isTable)
        {
            if (!rv.isTable())
            {
                throw new ParseException("Attempt to index non table variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new TableIndexer(queue, (Table)rv, v, v2);
        }

        instr.addVariable(rv);
    }
}

IValue valueExpression(InstructionQueue queue) :
{
    ValueExpression exp = new ValueExpression();
    IValue v;
    IValue left = null;
    IValue right = null;
    ValueExpression.Operator operator = ValueExpression.Operator.INVALID;
}
{
  (
    left = valueOperand(queue) 
    {
       exp.setOperand(true, left);
    }
    ( LOOKAHEAD(2) 
        operator = valueOperator() right = valueOperand(queue)
        {
            exp.setOperator(operator, right);
        }
    )*
    |
    <NOT> left = valueOperand(queue)
    {
       exp.setOperand(true, left);
       exp.setOperator(ValueExpression.Operator.NOT, left);
    }
  )
  {
      if (exp.getRightOperand() == null)
      {
          return exp.getLeftOperand();
      }
      else
      {
          return exp;
      }
  }
}

Token booleanValue() :
{
    Token t;
}
{
    t = <TRUE>
    {
       return t;
    }
    |
    t = <FALSE>
    {
       return t;
    }
}


Token doubleValue() :
{
    Token t;
}
{
    t = <FLOATLITERAL>
    {
       return t;
    }
}

Token integerValue() :
{
    Token t;
}
{
    t = <INTEGERLITERAL>
    {
       return t;
    }
}

String stringValue() :
{
    String t;
}
{
    (
        ( <SINGLEQUOTE>
        t = grabToCharacter('\'')
        )
        |
        ( <DOUBLEQUOTE>
        t = grabToCharacter('"')
        )
        |
        ( <NEWLINE>
        t = getNewLine()
        )
    )
    {
       return t;
    }
}

void whenClauses(Rule theRule) :
{}
{
   (
      conditionClause(theRule)
   )+
}

void conditionClause(Rule theRule) :
{
    IValue v;
}
{
   <CONDITION> v = valueExpression(theRule.getQueue()) ";"
   {
      theRule.addCondition(v);
   }
}

void ruleName(Rule theRule) :
{
  Token t;
}
{
  t = <name>
  {
     theRule.setName(t.image);
  }
}

ValueExpression.Operator valueOperator() :
{
}
{
    <PLUS>  { return ValueExpression.Operator.PLUS; }
    |
    <MINUS> { return ValueExpression.Operator.MINUS; }
    |
    <MULT> { return ValueExpression.Operator.MULT; }
    |
    <DIV> {  return ValueExpression.Operator.DIV; }
    |
    <STRCAT> { return ValueExpression.Operator.STRCAT; }
    |
    <EQUALS> { return ValueExpression.Operator.VALEQUALS; }
    |
    <STREQUALS> { return ValueExpression.Operator.STREQUALS; }
    |
    <NOTEQUALS> { return ValueExpression.Operator.NOTEQUALS; }
    |
    <NOT> <STREQUALS> {  return ValueExpression.Operator.STRNOTEQUALS; }
    |
    <GREATERTHAN> { return ValueExpression.Operator.GREATERTHAN; }
    |
    <LESSTHAN> { return ValueExpression.Operator.LESSTHAN; }
    |
    <GREATERTHANEQ> {  return ValueExpression.Operator.GREATERTHANEQ; }
    |
    <LESSTHANEQ> {  return ValueExpression.Operator.LESSTHANEQ; }
    |
    <AND> { return ValueExpression.Operator.AND; }
    |
    <OR> { return ValueExpression.Operator.OR;}
    |
    <IS> { return ValueExpression.Operator.BOOLEQUALS; }
}

IValue valueOperand(InstructionQueue queue) :
{
    Token t;
    IValue v = null;
    IValue v2 = null;
    String s;
    boolean b;
    boolean isArray = false;
    boolean isTable = false;
}
{
    t = doubleValue()
    { return new DoubleVariable(null, t.image); }
    |
    t = integerValue()
    { return new IntegerVariable(null, t.image); }
    |
    <TRUE>
    { return new BooleanVariable(null, true); }
    |
    <FALSE>
    { return new BooleanVariable(null, false); }
    |
    s = stringValue()
    { return new StringVariable(null, s); }
    |
    v = arrayValue(queue)
    { return v; }
    |
    v = referenceValue(queue)
    { return v; }
    |
    LOOKAHEAD(2) v = objectOperation(queue)
    { return v; }
    |
    LOOKAHEAD(2) v = objectDataValue(queue)
    { return v; }
    |
    LOOKAHEAD(2) t = <name>
    (
        LOOKAHEAD(3)
        (
            <LBRACKET> v = valueExpression(queue) <RBRACKET>
            {
               isArray = true;
            }
        )
        |
        (
            <LBRACKET> v = valueExpression(queue) <COMMA> v2 = valueExpression(queue) <RBRACKET>
            {
               isTable = true;
            }
        )
    )?
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            throw new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        if (isArray)
        {
            if (!rv.isArray())
            {
                throw new ParseException("Attempt to index non array variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new ArrayIndexer(queue, (Array)rv, v);
        }
        else if (isTable)
        {
            if (!rv.isTable())
            {
                throw new ParseException("Attempt to index non table variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new TableIndexer(queue, (Table)rv, v, v2);
        }

        v = rv;
    }
    { return v; }
    |
    LOOKAHEAD(3) <LPAREN>
    v = valueExpression(queue)
    <RPAREN>
    { return v; }
    
}

IValue referenceValue(InstructionQueue queue) :
{
    ReferenceVariable ref = new ReferenceVariable(null);
    IValue v;
}
{
    <LBRACE>
    v = valueExpression(queue)
    <RBRACE>
    {
        ref.setMonitor(queue.getRuleSet().getMonitor());
        ref.setValue(v, true);
        return ref;
    }
}

IValue arrayValue(InstructionQueue queue) :
{
    Array array = new Array(null);
    IValue v;
    Vector vector = new Vector();
}
{
    <LBRACKET>
    (
       v = valueExpression(queue) { vector.add(v); }
       (","
          v = valueExpression(queue) { vector.add(v); }
       )*
    )?
    <RBRACKET>
    {
        array.initialize(vector);
        return array;
    }
}

IValue objectDataValue(InstructionQueue queue) :
{
    ObjectMethodExpression exp = new ObjectMethodExpression();
    Token t;
    IValue val;
}
{
    t = <name>
    { exp.setObjectName(t.image, queue); }
    <VALUESEP>
    t = <name>
    { 
        exp.setMethodName("valueOf", true); 
        exp.addParameter(new StringVariable(null, t.image));
        exp.validateParameters();
        return exp;
    }
}

IValue objectOperation(InstructionQueue queue) :
{
    ObjectMethodExpression exp = new ObjectMethodExpression();
    Token t;
    IValue val;
    boolean useInvoke = true;
}
{
    t = <name>
    { exp.setObjectName(t.image, queue); }
    (
        <METHODSEP>
        t = <name>
        { exp.setMethodName(t.image); useInvoke = false; }
    )?
    <LPAREN>
    { if (useInvoke) exp.setMethodName("invoke"); }
    (
        (
           val = valueExpression(queue)
        )
        { exp.addParameter(val); }
        (
            ","
            (
                val = valueExpression(queue)
            )
            { exp.addParameter(val); }
        )*
    )?
    <RPAREN>
    {
        exp.validateParameters();
        return exp;
    }
}

String constant() :
{
    Token t;
    String s;
}
{
    t = doubleValue() { return t.image; }
    |
    t = integerValue() { return t.image; }
    |
    s = stringValue() { return s; }
    |
    t = booleanValue() { return t.image; }
}

JAVACODE

String grabToCharacter(char grab)
{
   StringBuffer buffer = new StringBuffer();
   SimpleCharStream s = CALRuleParserTokenManager.input_stream;

   try
   {
       char cc = s.readChar();
       while (cc != grab)
       {
          if (cc == '\\')
          {
             // get the next character too
             cc = s.readChar();
             if (cc == 'n')
             {
                buffer.append("\n");
             }
             else if (cc == 't')
             {
                buffer.append("\t");
             }
          }
          else
          {
              buffer.append(cc);
          }
          cc = s.readChar();
       }
   }
   catch (java.io.IOException e)
   {
      throw new RuntimeException(e.getMessage());
   }
   return buffer.toString();
}

JAVACODE

String getNewLine()
{
    return "\n";
}

