/*
 * Copyright 2010 the original author or authors.
 * Copyright 2009 Paxxis Technology LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This parser is used to parse json format text into
 * a JSON object set. This file is processed using JavaCC.
 */
PARSER_BEGIN(JSONParser)

package com.paxxis.chime.json.parser;

import java.io.*;
import java.util.*;
import com.paxxis.chime.json.JSONValue;
import com.paxxis.chime.json.JSONObject;
import com.paxxis.chime.json.JSONString;
import com.paxxis.chime.json.JSONBoolean;
import com.paxxis.chime.json.JSONDouble;
import com.paxxis.chime.json.JSONInteger;
import com.paxxis.chime.json.JSONNull;
import com.paxxis.chime.json.JSONArray;

/**
* This is the parser class.  Most of the code for
* the parser is generated by the grammar definition.
*
* @author Robert Englander
*/
public class JSONParser
{
    private static final String ESCAPEDCHARS = "brntfu/\\\"";
    private static Hashtable<Integer, String> _escapeMap = new Hashtable<Integer, String>();

    static
    {
        // NOTE:  u has no mapping.  the 4 characters that
        // follow u must be processed separately
        _escapeMap.put((int)'b', "\b");
        _escapeMap.put((int)'r', "\r");
        _escapeMap.put((int)'n', "\n");
        _escapeMap.put((int)'t', "\t");
        _escapeMap.put((int)'f', "\f");
        _escapeMap.put((int)'/', "/");
        _escapeMap.put((int)'\\', "\\");
        _escapeMap.put((int)'\"', "\"");
    }

    // we generate a static parser, so we keep
    // a singleton instance.
    protected static JSONParser _parser = null;
    protected static String _sourceCode = null;

    public static JSONParser create(String contents)
    {
        // save the most recent contents
        //_sourceCode = contents;

        // right now we only support reading from a String instance.  With
        // large data streams coming over some kind of feed it would be
        // useful to use some kind of stream reader, but for now this is fine.
        StringReader rdr = new StringReader(contents);

        /*
        if (_parser == null)
        {
            _parser = new JSONParser(rdr);
        }
        else
        {
            _parser.ReInit(rdr);
        }

        return _parser;
        */

        return new JSONParser(rdr);
        
    }

    public static String getSourceCode()
    {
        return _sourceCode;
    }
}

PARSER_END(JSONParser)

/**
 * This is used to strip off whitespace
 */
SPECIAL_TOKEN :
{
   < WHITESPACE: (" " | "\t" | "\n" | "\r") >
}

/**
 * The token definitions.
 */
TOKEN :
{
   < DOUBLEQUOTE: ("\"") >
|  < LBRACE: ("{") >
|  < RBRACE: ("}") >
|  < LBRACKET: ("[") >
|  < RBRACKET: ("]") >
|  < PLUS: ("+") >
|  < MINUS: ("-") >
|  < COMMA: (",") >
|  < TRUE: ("true" | "TRUE") >
|  < FALSE: ("false" | "FALSE") >
|  < NULL: ("null" | "NULL") >
|  < VALUESEP: (":") >
|  < INTEGERLITERAL: ("-")? (["0"-"9"])+ >
|  < EXP: ("E" | "e") (<PLUS> | <MINUS>) (["0"-"9"])+ >
|  < FLOATLITERAL: ("-")? (["0"-"9"])+ "." (["0"-"9"])+ (<EXP>)? >
}

/**
 * Users of this parser call this method after parser
 * creation to get a fully populated JSON object from
 * the input.
 */
JSONObject parse() :
{
    JSONObject object;
}
{
    // there should be a single top level json object
    object = jsonObject()
    {
        return object;
    }
}

/**
 * A JSON object
 */
JSONObject jsonObject() :
{
    JSONObject object = new JSONObject();
}
{
    <LBRACE>
    ( stringValuePairs(object) )?
    <RBRACE>
    {
        return object;
    }
}

void stringValuePairs(JSONObject object) :
{
}
{
   stringValuePair(object) (<COMMA> stringValuePair(object))*
}

void stringValuePair(JSONObject object) :
{
    JSONString name;
    JSONValue value;
}
{
    (
        name = stringValue()
    )
    <VALUESEP>
    (
        value = dataValue()
    )
    {
        object.set(name, value);   
    }
}

void dataValues(JSONArray array) :
{
   JSONValue value;
}
{
    value = dataValue()
    {
        array.add(value);
    }
    (
        <COMMA> 
        value = dataValue()
        {
            array.add(value);
        }
    )*
}

JSONValue dataValue() :
{
    JSONValue value;
}
{
    (
        value = constant()
        |
        value = jsonObject()
        |
        value = jsonArray()
    )
    {
        return value;
    }
}

JSONNull nullValue() :
{
}
{
    <NULL>
    {
       return new JSONNull();
    }
}

JSONBoolean booleanValue() :
{
}
{
    <TRUE>
    {
       return new JSONBoolean(true);
    }
    |
    <FALSE>
    {
       return new JSONBoolean(false);
    }
}

JSONDouble doubleValue() :
{
    Token t;
}
{
    t = <FLOATLITERAL>
    {
       return new JSONDouble(t.image);
    }
}

JSONInteger integerValue() :
{
    Token t;
}
{
    t = <INTEGERLITERAL>
    {
       return new JSONInteger(t.image);
    }
}

JSONString stringValue() :
{
    String t;
}
{
    (
        ( <DOUBLEQUOTE>
        t = grabToCharacter('"')
        )
    )
    {
       return new JSONString(t);
    }
}


JSONArray jsonArray() :
{
    JSONArray array = new JSONArray();
}
{
    <LBRACKET>
    ( dataValues(array) )?
    <RBRACKET>
    {
        return array;
    }
}

JSONValue constant() :
{
    JSONValue val;
}
{
    (
        val = doubleValue()
        |
        val = integerValue()
        |
        val = booleanValue()
        |
        val = nullValue()
        |
        val = stringValue()
    )
    {
        return val;
    }
}

JAVACODE

String grabToCharacter(char grab)
{
   StringBuffer buffer = new StringBuffer();
   SimpleCharStream s = token_source.input_stream; //JSONParserTokenManager.input_stream;

   try
   {
       char cc = s.readChar();
       while (cc != grab)
       {
          if (cc == '\\')
          {
             // get the next character too
             cc = s.readChar();
             if (isEscaped(cc))
             {
                 if (cc == 'u')
                 {
                     // the next 4 characters are a 4 digit hex number
                     char[] digits = {
                                        s.readChar(),
                                        s.readChar(),
                                        s.readChar(),
                                        s.readChar()
                                     };
                     buffer.append(getHexEscapeString(digits));
                 }
                 else
                 {
                     buffer.append(getEscapeString(cc));
                 }
             }
             else
             {
                 buffer.append("\\" + cc);
             }
          }
          else
          {
              buffer.append(cc);
          }

          cc = s.readChar();
       }
   }
   catch (java.io.IOException e)
   {
      throw new RuntimeException(e.getMessage());
   }

   return buffer.toString();
}


JAVACODE

boolean isEscaped(char c)
{
    return (-1 != ESCAPEDCHARS.indexOf((int)c));
}

JAVACODE

String getEscapeString(char c)
{
    return _escapeMap.get((int)c);
}

JAVACODE

String getHexEscapeString(char[] chars)
{
    // we can turn this one right back into a \\uXXXX
    String s = "\\u" + new String(chars).toUpperCase();

    return s;
}







