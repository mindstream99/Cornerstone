/*
 * Copyright 2010 Robert Englander
 * Copyright 2009 Paxxis Technology LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    STATIC = false;
}

/**
 * The CSL rule parser is used to parse rules into
 * a Rule Set. This file is processed using JavaCC.
 */
PARSER_BEGIN(CSLRuleParser)

/**
 * If you're going to extend the language, you'll need to generate your own parser.
 * So copy this file into your own package directory, and change the package specification
 * below to your own package.
 */
package com.paxxis.cornerstone.scripting.parser;

import java.io.*;
import java.util.*;
import com.paxxis.cornerstone.scripting.*;

/**
 * Add an import to your own scripting classes here
 */
 
/**
 * This is the parser class.  Most of the code for
 * the parser is generated by the grammar definition.
 *
 * If you are generating an extended parser, you should change
 * CSLRuleParser to something that make sense for your use case.
 */
public class CSLRuleParser implements RuleParser
{
	private static final String DEFAULTNAME = "default";
	
    protected String _sourceCode = null;
    protected String ruleSetName = DEFAULTNAME;
    protected int ruleCount = 0;
    
    public CSLRuleParser() {
    }
    
    public void initialize(String contents) {
        StringReader rdr = new StringReader(contents);
	    jj_input_stream = new SimpleCharStream(rdr, 1, 1);
    	token_source = new CSLRuleParserTokenManager(jj_input_stream);
    	token = new Token();
    	this.ReInit(rdr);
        _sourceCode = contents;

		ruleSetName = DEFAULTNAME;
		ruleCount = 0;
    }

    public String getSourceCode()
    {
        return _sourceCode;
    }
}

PARSER_END(CSLRuleParser)

SPECIAL_TOKEN :
{
   < WHITESPACE: (" " | "\t" | "\n" | "\r" | "\u00A0") >
}

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
  |
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/**
 * Add any new tokens that you need if your language extensions require additional tokens.
 * Do Not remove any of the base tokens unless you are removing base grammar that uses them...................
 */
TOKEN :
{
   < SINGLEQUOTE: ("'") >
|  < DOUBLEQUOTE: ("\"") >
|  < LBRACE: ("{") >
|  < RBRACE: ("}") >
|  < LPAREN: ("(") >
|  < RPAREN: (")") >
|  < LBRACKET: ("[") >
|  < RBRACKET: ("]") >
|  < ASSIGNMENT: ("=") >
|  < PLUS: ("+") >
|  < MINUS: ("-") >
|  < MULT: ("*") >
|  < DIV: ("/") >
|  < COMMA: (",") >
|  < EQUALS: ("==") >
|  < NOTEQUALS: ("!=") >
|  < STREQUALS: ("equals" | "EQUALS") >
|  < STRCONTAINS: ("contains" | "CONTAINS") >
|  < STRCAT: ("|") >
|  < GREATERTHAN: (">") >
|  < LESSTHAN: ("<") >
|  < GREATERTHANEQ: (">=") >
|  < LESSTHANEQ: ("<=") >
|  < DO: ("DO" | "do") >
|  < WHEN: ("WHEN" | "when") >
|  < SET: ("set" | "SET") >
|  < TO: ("to" | "TO") >
|  < MERGE: ("merge" | "MERGE") >
|  < INTO: ("into" | "INTO") >
|  < ANNO_DESCRIPTION: ("@description" | "@Description" | "@DESCRIPTION") >
|  < RULESET: ("ruleset" | "RULESET") >
|  < RULE: ("rule" | "Rule" | "RULE") >
|  < SWITCH: ("switch" | "SWITCH") >
|  < CASE: ("case" | "CASE") >
|  < EVENT: ("event" | "EVENT") >
|  < TIMER: ("timer" | "TIMER") >
|  < DEFCASE: ("default" | "DEFAULT") >
|  < CONDITION: ("condition" | "CONDITION") >
|  < CHANGES: ("changes" | "CHANGES") >
|  < RETURNS: ("returns" | "RETURNS") >
|  < RETURN: ("return" | "RETURN") >
|  < RESULT: ("Result") >
|  < TRUE: ("true" | "TRUE") >
|  < FALSE: ("false" | "FALSE") >
|  < REFERENCE: ("Reference") >
|  < VARIABLE: ("variable" | "VARIABLE") >
|  < START: ("start" | "START") >
|  < DURABLE: ("durable" | "DURABLE") >
|  < DYNAMIC: ("dynamic" | "DYNAMIC") >
|  < MACRO: ("macro" | "MACRO") >
|  < AS: ("as" | "AS") >
|  < ON: ("on" | "ON") >
|  < BEFORE: ("before" | "BEFORE") >
|  < AFTER: ("after" | "AFTER") >
|  < FOREACH: ("foreach" | "FOREACH") >
|  < IF: ("if" | "IF") >
|  < IN: ("in" | "IN") >
|  < ELSE: ("else" | "ELSE") >
|  < ELSEIF: ("elseif" | "ELSEIF") >
|  < WHILE: ("while" | "WHILE") >
|  < BREAK: ("break" | "BREAK") >
|  < ERROR: ("error" | "ERROR") >
|  < ASSERT: ("assert" | "ASSERT") >
|  < METHODSEP: (":") >
|  < VALUESEP: ("::") >
|  < IS: ("is" | "IS" | "are" | "ARE") >
|  < AND: ("and" | "AND") >
|  < OR: ("or" | "OR") >
|  < NOT: ("not" | "NOT") >
|  < WAIT: ("wait" | "WAIT") >
|  < UNTIL: ("until" | "UNTIL") >
|  < ARRAY: ("Array") >
|  < TABLE: ("Table") >
|  < INTEGER: ("Integer") >
|  < DOUBLE: ("Double") >
|  < BOOLEAN: ("Boolean") >
|  < STRING: ("String") >
|  < DATE: ("Date") >
|  < EXTENSION: ("Extension") >
|  < PRINT: ("print" | "PRINT") >
|  < NEWLINE: ("newLine") >
|  < name: (["a"-"z","A"-"Z","@","_","."]) (["a"-"z","A"-"Z",".","_","@","?","&","0"-"9","\\"])* >
|  < INTEGERLITERAL: ("-")? (["0"-"9"])+ >
|  < DATELITERAL: (<INTEGERLITERAL> "/" <INTEGERLITERAL> "/" <INTEGERLITERAL>)  >
|  < FLOATLITERAL: (["0"-"9"])+ "." (["0"-"9"])+ >
}

void parseRuleSet(RuleSet ruleSet) :
{
	Token t;
    Rule rule;
}
{
    (rule = parseRule(ruleSet)
    {
        try
        {
            ruleSet.addRule(rule);
        }
        catch (Exception rce)
        {
            throw new ParseException(rce.getMessage());
        }
    }
    )+

}

Rule parseRule(RuleSet ruleSet) :
{
    Rule theRule = new Rule(ruleSet);
    Token t;
    boolean ruleSetDeclared = false;
}
{
	{ ruleCount++; }
  	(
  		<RULESET> t = <name>
  		{
   	  		ruleSetName = t.image;
   	  		ruleSetDeclared = true;
  		}
  	)?
  	{
  		if (ruleCount == 1 && !ruleSetDeclared) {
            throw new ParseException("You must declare a ruleset before the first rule definition.");
  		}
  	}
  	rule(theRule)
  	{
   		return theRule;
  	}
}

void rule(Rule theRule) :
{
	String desc = null;
    Token t;
    RuleVariable returnVariable = new StringVariable("#return") ;
}
{
  (
  	  <ANNO_DESCRIPTION> desc = stringValue()
  	  {
  	  	  theRule.setDescription(desc);
  	  }
  )?
  (
      returnVariable = returnType()
  )?
  {
      theRule.setReturnValue(returnVariable);
  }
  ruleName(theRule)
  "(" (ruleParams(theRule))? ")"
  <LBRACE>
  (<WHEN> ":" whenClauses(theRule))?
  doClauses(theRule, theRule.getQueue())
  (<ON> <ERROR> ":" doClauses(theRule, theRule.getErrorQueue()))?
  <RBRACE>
}

RuleVariable returnType() :
{}
{
    <STRING> { return new StringVariable("#return"); }
    |
    <DOUBLE> { return new DoubleVariable("#return"); }
    |
    <BOOLEAN> { return new BooleanVariable("#return"); }
    |
    <INTEGER> { return new IntegerVariable("#return"); }
    |
    <RESULT> { return new ResultVariable("#return"); }
    |
    <DATE> { return new DateVariable("#return"); }
    |
    <ARRAY> { return new Array("#return"); }
    |
    <TABLE> { return new Table("#return"); }
    |
    <EXTENSION> { return new Extension("#return"); }
}

void ruleParams(Rule theRule) :
{}
{
   ruleParam(theRule) ("," ruleParam(theRule))*
}

void ruleParam(Rule theRule) :
{
    Token tname;
    RuleVariable param;
}
{
    param = parameter()
    {
        try
        {
            theRule.getQueue().addParameter(param);
        }
        catch (RuleCreationException e)
        {
            Token tt = getToken(0);
            StringBuffer buf = new StringBuffer(e.getMessage());
            buf.append("\nRule: " + theRule.getName() + "\nLine " + tt.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buf.toString());
        }
    }
}

RuleVariable parameter() :
{
    Token t;
    Token defaultToken = null;
    String defaultValue = null;
}
{
    <STRING> t = variablename() (LOOKAHEAD(2) defaultValue = stringValue())?
    { 
        StringVariable sv = new StringVariable(t.image);
        if (defaultValue != null) {
            sv.setParameterDefaultValue(defaultValue);
        }
        return sv; 
    }
    |
    <DOUBLE> t = variablename() (LOOKAHEAD(2) (defaultToken = doubleValue() | defaultToken = integerValue()))?
    { 
        DoubleVariable dv = new DoubleVariable(t.image);
        if (defaultToken != null) {
            dv.setParameterDefaultValue(defaultToken.image);
        }
        return dv; 
    }
    |
    <INTEGER> t = variablename() (LOOKAHEAD(2) defaultToken = integerValue())?
    { 
        IntegerVariable iv = new IntegerVariable(t.image);
        if (defaultToken != null) {
            iv.setParameterDefaultValue(defaultToken.image);
        }
        return iv; 
    }
    |
    <RESULT> t = variablename()
    { 
        ResultVariable resv = new ResultVariable(t.image);
        resv.setHasParameterDefault(true);
        return resv; 
    }
    |
    <DATE> t = variablename() (LOOKAHEAD(2) defaultValue = stringValue())?
    { 
        DateVariable dtv = new DateVariable(t.image);
        if (defaultToken != null) {
            dtv.setParameterDefaultValue(defaultToken.image);
        }
        return dtv; 
    }
    |
    <BOOLEAN> t = variablename() (LOOKAHEAD(2) defaultToken = booleanValue())?
    { 
        BooleanVariable bv = new BooleanVariable(t.image);
        if (defaultToken != null) {
            bv.setParameterDefaultValue(defaultToken.image);
        }
        return bv; 
    }
    |
    <ARRAY> t = variablename()
    { 
        Array array = new Array(t.image);
        array.setHasParameterDefault(true);
        return array; 
    }
    |
    <TABLE> t = variablename()
    { 
        Table table = new Table(t.image);
        table.setHasParameterDefault(true);
        return table; 
    }
    |
    <EXTENSION> t = variablename()
    { return new Extension(t.image); }
    |
    <REFERENCE> t = variablename()
    { 
        ReferenceVariable refv = new ReferenceVariable(t.image);
        refv.setHasParameterDefault(true);
        return refv; 
    }
}

Token variablename() :
{
    Token t;
}
{
    t = <name>
    {
        return t;
    }
}

void doClauses(Rule theRule, InstructionQueue queue) :
{}
{
   (LOOKAHEAD(2) doClause(theRule, queue))*
}

void doClause(Rule theRule, InstructionQueue queue) :
{
}
{
   LOOKAHEAD(3) nullObjectOperation(queue) ";"
   |
   LOOKAHEAD(2) defineVariableClause(queue) ";"
   |
   returnClause(theRule, queue) ";"
   |
   errorClause(theRule, queue) ";"
   |
   assertClause(theRule, queue) ";"
   |
   LOOKAHEAD(3) setVariableClause(queue) ";"
   |
   switchClause(theRule, queue)
   |
   ifClause(theRule, queue)
   |
   forEachClause(theRule, queue)
   |
   whileClause(theRule, queue)
   |
   breakClause(queue) ";"
   |
   printClause(queue) ";"
   |
   LOOKAHEAD(3) mergeResultsClause(queue) ";"
   |
   LOOKAHEAD(2) valueExpression(queue) ";"
}

void nullObjectOperation(InstructionQueue queue) :
{
    IValue v;
}
{
    v = objectOperation(queue)
    {
        EvaluationInstruction ei = new EvaluationInstruction(v);
        ei.setLineNumber(token.beginLine);
        queue.addInstruction(ei);
    }
}

void mergeResultsClause(InstructionQueue queue) :
{
    IValue source;
    IValue target;
}
{
    <MERGE> source = valueExpression(queue) <INTO> target = valueExpression(queue)
    {
        try {
            if ( !(target instanceof ResultVariable) ) {
                throw new RuleCreationException("Target of merge must be a Result."); 
            }
            
            ResultVariable rv = (ResultVariable)target;
            ObjectMethodExpression exp = new ObjectMethodExpression();
            exp.setObjectName(rv.getName(), queue); 
            exp.setMethodName("mergeWith"); 
            exp.addParameter(source);
    
            EvaluationInstruction ei = new EvaluationInstruction(exp);
            ei.setLineNumber(token.beginLine);
            queue.addInstruction(ei);
        } catch (RuleCreationException rce) {
            StringBuffer buffer = new StringBuffer(rce.getMessage());
            buffer.append("\nLine " + token.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buffer.toString());
        }
    }
}

void printClause(InstructionQueue queue) :
{
    IValue v;
}
{
    <PRINT> v = valueExpression(queue)
    {
        PrintInstruction pi = new PrintInstruction(v);
        pi.setLineNumber(token.beginLine);
        queue.addInstruction(pi);
    }
}

void returnClause(Rule theRule, InstructionQueue queue) :
{
    IValue v;
}
{
    <RETURN>
    (
        v = valueExpression(queue)
    )
    {
        ReturnInstruction ri = new ReturnInstruction();
        try
        {
            ri.setValue(theRule, v);
        }
        catch (RuleCreationException rce)
        {
            StringBuffer buffer = new StringBuffer(rce.getMessage());
            buffer.append("\nLine " + token.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buffer.toString());
        }
        ri.setLineNumber(token.beginLine);
        queue.addInstruction(ri);
    }
}

void errorClause(Rule theRule, InstructionQueue queue) :
{
    IValue code = new IntegerVariable(null, 0);
    IValue desc = new StringVariable(null, "");
}
{
    <ERROR>
    (
        code = valueExpression(queue)
    	(  <COMMA> desc = valueExpression(queue) )?
    )
    {
        ErrorInstruction ri = new ErrorInstruction();
        try
        {
            ri.setValue(theRule, desc);
            ri.setCode(code);
        }
        catch (RuleCreationException rce)
        {
            StringBuffer buffer = new StringBuffer(rce.getMessage());
            buffer.append("\nLine " + token.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buffer.toString());
        }
        ri.setLineNumber(token.beginLine);
        queue.addInstruction(ri);
    }
}

void assertClause(Rule theRule, InstructionQueue queue) :
{
    IValue cond;
    IValue msg = new StringVariable(null, "Assertion Failed");
}
{
    <ASSERT>
    (
        cond = valueExpression(queue)
     	(
    		<METHODSEP> msg = valueExpression(queue)
        )?
    )
    {
        AssertInstruction ri = new AssertInstruction(theRule, cond, msg);
        ri.setLineNumber(token.beginLine);
        queue.addInstruction(ri);
    }
}

void breakClause(InstructionQueue queue) :
{}
{
    <BREAK>
    {
        BreakInstruction bi = new BreakInstruction();
        bi.setLineNumber(token.beginLine);
        queue.addInstruction(bi);
    }
}

void defineVariableClause(InstructionQueue queue) :
{
    RuleVariable var = null;
    SetInstruction si;
    IValue v = null;
    Token t;
    boolean durable = false;
    boolean dynamic = false;
    boolean macro = false;
}
{
    ( 
        <DURABLE>
        { durable = true; }
    )?
    ( 
        <DYNAMIC>
        { dynamic = true; }
    )?
    ( 
        <MACRO>
        { macro = true; }
    )?
    (
        LOOKAHEAD(2) var = parameter()
        |
        <ARRAY> <LPAREN> (v = valueExpression(queue))? <RPAREN> t = variablename()
        {
            var = new Array(t.image);
            CreateArrayInstruction cai = new CreateArrayInstruction(t.image, v);
            cai.setLineNumber(token.beginLine);
            queue.addInstruction(cai);
        }
        |
        <TABLE> t = variablename()
        {
            var = new Table(t.image);
            CreateTableInstruction cti = new CreateTableInstruction(t.image);
            cti.setLineNumber(token.beginLine);
            queue.addInstruction(cti);
        }
        |
        <RULE> t = variablename()
        {
            var = new RuleAccessor(t.image, queue);
        }
        |
        <REFERENCE> t = variablename()
        {
            var = new ReferenceVariable(t.image);
        }
    )
    {
        try
        {
            var.setDurable(durable);
            var.setDynamic(dynamic);
            var.setMacro(macro);
            queue.addVariable(var);
        }
        catch (RuleCreationException e)
        {
            Token tt = getToken(0);
            StringBuffer buf = new StringBuffer(e.getMessage());
            buf.append("\nLine " + tt.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buf.toString());
        }
    }
    (
        <ASSIGNMENT>
        {
            si = new SetInstruction();
            si.addVariable(var);
        }
        v = valueExpression(queue)
        {
            si.setValue(v);
            si.setLineNumber(token.beginLine);
            queue.addInstruction(si);
        }
    )?
}

void switchClause(Rule theRule, InstructionQueue queue) :
{
    SwitchInstruction inst = new SwitchInstruction(queue);
    IValue v;
    String s;
    int _firstLine;
}
{
    <SWITCH>
    { _firstLine = token.beginLine; }
    (<STRING> { inst.setStringMatching(true); } )?
    <LPAREN>
    v = valueExpression(queue) { inst.setValue(v); }
    <RPAREN>
    <LBRACE>
    (
      <CASE>
      {
         InstructionQueue q = new InstructionQueue();
         q.setParent(queue);
      }
      s = constant() ":"
      doClauses(theRule, q)
      {
         inst.addCase(s, q);
      }
    )+
    (
      <DEFCASE> ":"
      {
         InstructionQueue q = new InstructionQueue();
         q.setParent(queue);
      }
      doClauses(theRule, q) { inst.setDefaultCase(q); }
    )?
    <RBRACE>
    {
        inst.setLineNumber(_firstLine);
        queue.addInstruction(inst);
    }
}

void forEachClause(Rule theRule, InstructionQueue queue) :
{
    IValue startValue;
    IValue endValue;
    ForEachInstruction fei = new ForEachInstruction(queue);
    Token t;
}
{
    <FOREACH> <LPAREN> t = variablename() <IN> startValue = valueExpression(queue) <TO> endValue = valueExpression(queue) <RPAREN>
    {
        fei.getBlock().setParent(queue);
        IntegerVariable index = new IntegerVariable(t.image, startValue.valueAsInteger());
        index.setDurable(true);
        index.setUserMutable(false);

        try {
        	fei.setIndexVariable(index);
        } catch (RuleCreationException e) {
            Token tt = getToken(0);
            StringBuffer buf = new StringBuffer(e.getMessage());
            buf.append("\nLine " + tt.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buf.toString());
        }

        fei.setIndexStartValue(startValue);
        fei.setIndexEndValue(endValue);
        fei.setLineNumber(token.beginLine);
        queue.addInstruction(fei);
    }
    <LBRACE>
    doClauses(theRule, fei.getBlock())
    <RBRACE>
}

void whileClause(Rule theRule, InstructionQueue queue) :
{
    IValue condition;
    WhileInstruction wi;
}
{
    <WHILE> <LPAREN> condition = valueExpression(queue) <RPAREN>
    {
        wi = new WhileInstruction(queue);
        wi.getBlock().setParent(queue);
        wi.setCondition(condition);
        wi.setLineNumber(token.beginLine);
        queue.addInstruction(wi);
    }
    <LBRACE>
    doClauses(theRule, wi.getBlock())
    <RBRACE>
}

void ifClause(Rule theRule, InstructionQueue queue) :
{
    IValue condition;
    IfInstruction ii = new IfInstruction(queue);
    InstructionQueue q;
}
{
    <IF> <LPAREN> condition = valueExpression(queue) <RPAREN>
    {
        ii.setCondition(condition);
        ii.setLineNumber(token.beginLine);
        queue.addInstruction(ii);
        ii.getIfBlock().setParent(queue);
    }
    <LBRACE>
    doClauses(theRule, ii.getIfBlock())
    <RBRACE>
    (
       LOOKAHEAD(2) <ELSE> <IF> <LPAREN> condition = valueExpression(queue) <RPAREN>
       <LBRACE>
       {
           q = ii.addElseIfBlock(condition);
           q.setParent(queue);
       }
       doClauses(theRule, q)
       <RBRACE>
    )*
    (
       <ELSE> <LBRACE>
       { ii.getElseBlock().setParent(queue); }
       doClauses(theRule, ii.getElseBlock())
       <RBRACE>
    )?
}

void setVariableClause(InstructionQueue queue) :
{
    SetInstruction instr = new SetInstruction();
    IValue v;
}
{
    (
       (
          setvariables(queue, instr)
          <ASSIGNMENT>
          v = valueExpression(queue)
          {
             instr.setValue(v);
          }
       )
       |
       (
          <SET> <TO>
          v = valueExpression(queue)
          {
             instr.setValue(v);
          }
          ":" setvariables(queue, instr)
       )
    )
    {
        instr.setLineNumber(token.beginLine);
        queue.addInstruction(instr);
    }
}

void setvariables(InstructionQueue queue, SetInstruction instr) :
{}
{
   setvariable(queue, instr) ("," setvariable(queue, instr))*
}

void setvariable(InstructionQueue queue, SetInstruction instr) :
{
    Token t;
    IValue v = null;
    IValue v2 = null;
    boolean isArray = false;
    boolean isTable = false;
}
{
    t = <name>
    (
        LOOKAHEAD(3)
        (
            <LBRACKET> v = valueExpression(queue) <RBRACKET>
            {
               isArray = true;
            }
        )
        |
        (
            <LBRACKET> v = valueExpression(queue) <COMMA> v2 = valueExpression(queue) <RBRACKET>
            {
               isTable = true;
            }
        )
    )?
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            throw new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        if (isArray)
        {
            if (!rv.isArray())
            {
                throw new ParseException("Attempt to index non array variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new ArrayIndexer(queue, (Array)rv, v);
        }
        else if (isTable)
        {
            if (!rv.isTable())
            {
                throw new ParseException("Attempt to index non table variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new TableIndexer(queue, (Table)rv, v, v2);
        }

        instr.addVariable(rv);
    }
}

IValue valueExpression(InstructionQueue queue) :
{
    ValueExpression exp = new ValueExpression();
    IValue v;
    IValue left = null;
    IValue right = null;
    ValueExpression.Operator operator = ValueExpression.Operator.INVALID;
}
{
  (
    left = valueOperand(queue) 
    {
       exp.setOperand(true, left);
    }
    ( LOOKAHEAD(2) 
        operator = valueOperator() right = valueOperand(queue)
        {
            exp.setOperator(operator, right);
        }
    )*
    |
    <NOT> left = valueOperand(queue)
    {
       exp.setOperand(true, left);
       exp.setOperator(ValueExpression.Operator.NOT, left);
    }
  )
  {
      if (exp.getRightOperand() == null)
      {
          return exp.getLeftOperand();
      }
      else
      {
          return exp;
      }
  }
}

Token booleanValue() :
{
    Token t;
}
{
    t = <TRUE>
    {
       return t;
    }
    |
    t = <FALSE>
    {
       return t;
    }
}


Token doubleValue() :
{
    Token t;
}
{
    t = <FLOATLITERAL>
    {
       return t;
    }
}

Token integerValue() :
{
    Token t;
}
{
    t = <INTEGERLITERAL>
    {
       return t;
    }
}

String stringValue() :
{
    String t;
}
{
    (
        ( <SINGLEQUOTE>
        t = grabToCharacter('\'')
        )
        |
        ( <DOUBLEQUOTE>
        t = grabToCharacter('"')
        )
        |
        ( <NEWLINE>
        t = getNewLine()
        )
    )
    {
       return t;
    }
}

void whenClauses(Rule theRule) :
{}
{
   (
      conditionClause(theRule)
   )+
}

void conditionClause(Rule theRule) :
{
    IValue v;
}
{
   <CONDITION> v = valueExpression(theRule.getQueue()) ";"
   {
      theRule.addCondition(v);
   }
}

void ruleName(Rule theRule) :
{
  Token t;
}
{
  t = <name>
  {
     theRule.setName(ruleSetName + "$" + t.image);
  }
}

ValueExpression.Operator valueOperator() :
{
}
{
    <PLUS>  { return ValueExpression.Operator.PLUS; }
    |
    <MINUS> { return ValueExpression.Operator.MINUS; }
    |
    <MULT> { return ValueExpression.Operator.MULT; }
    |
    <DIV> {  return ValueExpression.Operator.DIV; }
    |
    <STRCAT> { return ValueExpression.Operator.STRCAT; }
    |
    <EQUALS> { return ValueExpression.Operator.VALEQUALS; }
    |
    <STREQUALS> { return ValueExpression.Operator.STREQUALS; }
    |
    <NOTEQUALS> { return ValueExpression.Operator.NOTEQUALS; }
    |
    <NOT> <STREQUALS> {  return ValueExpression.Operator.STRNOTEQUALS; }
    |
    <GREATERTHAN> { return ValueExpression.Operator.GREATERTHAN; }
    |
    <LESSTHAN> { return ValueExpression.Operator.LESSTHAN; }
    |
    <GREATERTHANEQ> {  return ValueExpression.Operator.GREATERTHANEQ; }
    |
    <LESSTHANEQ> {  return ValueExpression.Operator.LESSTHANEQ; }
    |
    <AND> { return ValueExpression.Operator.AND; }
    |
    <OR> { return ValueExpression.Operator.OR;}
    |
    <IS> { return ValueExpression.Operator.BOOLEQUALS; }
}

IValue valueOperand(InstructionQueue queue) :
{
    Token t;
    IValue v = null;
    IValue v2 = null;
    String s;
    boolean b;
    boolean isArray = false;
    boolean isTable = false;
}
{
    t = doubleValue()
    { return new DoubleVariable(null, t.image); }
    |
    t = integerValue()
    { return new IntegerVariable(null, t.image); }
    |
    <TRUE>
    { return new BooleanVariable(null, true); }
    |
    <FALSE>
    { return new BooleanVariable(null, false); }
    |
    s = stringValue()
    { return new StringVariable(null, s); }
    |
    v = arrayValue(queue)
    { return v; }
    |
    v = referenceValue(queue)
    { return v; }
    |
    LOOKAHEAD(2) v = objectOperation(queue)
    { return v; }
    |
    LOOKAHEAD(2) v = objectDataValue(queue)
    { return v; }
    |
    LOOKAHEAD(2) t = <name>
    (
        LOOKAHEAD(3)
        (
            <LBRACKET> v = valueExpression(queue) <RBRACKET>
            {
               isArray = true;
            }
        )
        |
        (
            <LBRACKET> v = valueExpression(queue) <COMMA> v2 = valueExpression(queue) <RBRACKET>
            {
               isTable = true;
            }
        )
    )?
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            throw new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
        }

        if (isArray)
        {
            if (!rv.isArray())
            {
                throw new ParseException("Attempt to index non array variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new ArrayIndexer(queue, (Array)rv, v);
        }
        else if (isTable)
        {
            if (!rv.isTable())
            {
                throw new ParseException("Attempt to index non table variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
            }
            rv = new TableIndexer(queue, (Table)rv, v, v2);
        }

        v = rv;
    }
    { return v; }
    |
    LOOKAHEAD(3) <LPAREN>
    v = valueExpression(queue)
    <RPAREN>
    { return v; }
    
}

IValue referenceValue(InstructionQueue queue) :
{
    ReferenceVariable ref = new ReferenceVariable(null);
    IValue v;
}
{
    <LBRACE>
    v = valueExpression(queue)
    <RBRACE>
    {
        ref.setRuntime(queue.getRuleSet().getRuntime());
        ref.setValue(v, true);
        return ref;
    }
}

IValue arrayValue(InstructionQueue queue) :
{
    Array array = new Array(null);
    IValue v;
    Vector vector = new Vector();
}
{
    <LBRACKET>
    (
       v = valueExpression(queue) { vector.add(v); }
       (","
          v = valueExpression(queue) { vector.add(v); }
       )*
    )?
    <RBRACKET>
    {
        array.initialize(vector);
        return array;
    }
}

IValue objectOperation(InstructionQueue queue) :
{
	IValue v;
}
{
    (
		v = directObjectOperation(queue)
	)
	{
		return v;
	}
}

IValue objectDataValue(InstructionQueue queue) :
{
    ObjectMethodExpression exp = new ObjectMethodExpression();
    Token nameToken;
    Token nameSpaceToken = null;
    Token t;
    IValue val;
}
{
    ( LOOKAHEAD(2)
       nameSpaceToken = <name> "$"
    )?
    nameToken = <name>
    { 
        String qualifier;
        String nm = nameToken.image;
        if (nameSpaceToken != null) {
            nm = nameSpaceToken.image + "$" + nm;
        } else {
            nm = ruleSetName + "$" + nm;
        }
         
        exp.setObjectName(nm, queue); 
    }
    <VALUESEP>
    t = <name>
    { 
        exp.setMethodName("valueOf", true); 
        exp.addParameter(new StringVariable(null, t.image));
        exp.validateParameters();
        return exp;
        
    }
}

IValue directObjectOperation(InstructionQueue queue) :
{
    ObjectMethodExpression exp = new ObjectMethodExpression();
    Token nameToken;
    Token nameSpaceToken = null;
    Token t2 = null;
    IValue val;
    boolean useInvoke = true;
}
{
    ( LOOKAHEAD(2)
       nameSpaceToken = <name> "$"
    )?
    nameToken = <name>
    (
        <METHODSEP>
        t2 = <name>
        { 
            useInvoke = false; 
        }
    )?
    <LPAREN>
    { 
        String nm = nameToken.image;
        if (useInvoke) {
            if (nameSpaceToken != null) {
                nm = nameSpaceToken.image + "$" + nm;
            } else {
                nm = ruleSetName + "$" + nm;
            }
        } 

        exp.setObjectName(nm, queue); 

        if (useInvoke) {
            exp.setMethodName("invoke");
        } else {
            exp.setMethodName(t2.image); 
        }
    }
    (
        (
           val = valueExpression(queue)
        )
        { exp.addParameter(val); }
        (
            ","
            (
                val = valueExpression(queue)
            )
            { exp.addParameter(val); }
        )*
    )?
    <RPAREN>
    {
        exp.validateParameters();
        return exp;
    }
}

String constant() :
{
    Token t;
    String s;
}
{
    t = doubleValue() { return t.image; }
    |
    t = integerValue() { return t.image; }
    |
    s = stringValue() { return s; }
    |
    t = booleanValue() { return t.image; }
}

JAVACODE

String grabToCharacter(char grab)
{
   StringBuffer buffer = new StringBuffer();
   SimpleCharStream s = this.token_source.input_stream;

   try
   {
       char cc = s.readChar();
       while (cc != grab)
       {
          if (cc == '\\')
          {
             // get the next character too
             cc = s.readChar();
             if (cc == 'n')
             {
                buffer.append("\n");
             }
             else if (cc == 't')
             {
                buffer.append("\t");
             }
             else 
             {
             	buffer.append(cc);
             }
          }
          else
          {
              buffer.append(cc);
          }
          cc = s.readChar();
       }
   }
   catch (java.io.IOException e)
   {
      throw new RuntimeException(e.getMessage());
   }
   return buffer.toString();
}

JAVACODE

String getNewLine()
{
    return "\n";
}

