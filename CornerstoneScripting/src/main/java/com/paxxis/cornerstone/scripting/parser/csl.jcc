/*
 * Copyright 2010 Robert Englander
 * Copyright 2009 Paxxis Technology LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  ERROR_REPORTING = true;
  STATIC = false;
  JDK_VERSION = "1.5";
  BUILD_PARSER = true;
}

/**
 * The CSL rule parser is used to parse rules into
 * a Rule Set. This file is processed using JavaCC.
 */
PARSER_BEGIN(CSLRuleParser)

/**
 * If you're going to extend the language, you'll need to generate your own parser.
 * So copy this file into your own package directory, and change the package specification
 * below to your own package.
 */
package com.paxxis.cornerstone.scripting.parser;

import java.io.*;
import java.util.*;
import com.paxxis.cornerstone.scripting.parser.RuleParser;
import com.paxxis.cornerstone.scripting.*;

/**
 * Add an import to your own scripting classes here
 */
 
/**
 * This is the parser class.  Most of the code for
 * the parser is generated by the grammar definition.
 *
 * If you are generating an extended parser, you should change
 * CSLRuleParser to something that make sense for your use case.
 */
public class CSLRuleParser implements RuleParser {
    
    private static class ParameterPair {
        RuleVariable var;
        Token token;
    }

    private static final String DEFAULTNAME = "default";
    
    protected String _sourceCode = null;
    protected String ruleSetName = DEFAULTNAME;
    protected int ruleCount = 0;
    protected List<ParseException> syntaxErrors = new ArrayList<ParseException>();

    public CSLRuleParser() {
    }
    
    public void initialize(String contents) {
        StringReader rdr = new StringReader(contents);
        jj_input_stream = new JavaCharStream(rdr, 1, 1);
        token_source = new CSLRuleParserTokenManager(jj_input_stream);
        token = new Token();
        this.ReInit(rdr);
        _sourceCode = contents;

        ruleSetName = DEFAULTNAME;
        ruleCount = 0;
    }

    public boolean hasParseErrors() {
        return syntaxErrors.size() > 0;
    }
    
    public List<ParseException> getParseErrors() {
        List<ParseException> list = new ArrayList<ParseException>();
        list.addAll(syntaxErrors);
        return list;
    }

    public void recover (ParseException ex, int recoveryPoint) {
    	int[] a = {recoveryPoint};
    	recover(ex, a);
    }
    
    public void recover (ParseException ex, int[] recoveryPoints) {
        recover(ex, recoveryPoints, 0);
    }

    public void recover (ParseException ex, int recoveryPoint, int offset) {
    	int[] a = {recoveryPoint};
		recover(ex, a, offset);    
    }
    
    public void recover (ParseException ex, int[] recoveryPoints, int offset) {
        syntaxErrors.add (ex);
        Token t;
        do {
            t = getNextToken ();
        } while (t.kind != EOF && !matches(t.kind, recoveryPoints));
        
        for (int i = 0; i < offset; i++) {
            t = getNextToken();
        }
    }

    public boolean matches(int k, int[] list) {
    	for (int l : list) {
    		if (l == k) {
    			return true;
    		}
    	}
    	return false;
    }
    
    public String getSourceCode()
    {
        return _sourceCode;
    }
}

PARSER_END(CSLRuleParser)

SPECIAL_TOKEN :
{
   < WHITESPACE: (" " | "\t" | "\n" | "\r" | "\u00A0") >
}

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
  |
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" | "\u0000" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/**
 * Add any new tokens that you need if your language extensions require additional tokens.
 * Do Not remove any of the base tokens unless you are removing base grammar that uses them...................
 */
TOKEN :
{
   < LBRACE: ("{") >
|  < RBRACE: ("}") >
|  < LPAREN: ("(") >
|  < RPAREN: (")") >
|  < LBRACKET: ("[") >
|  < RBRACKET: ("]") >
|  < ASSIGNMENT: ("=") >
|  < PLUS: ("+") >
|  < MINUS: ("-") >
|  < MULT: ("*") >
|  < DIV: ("/") >
|  < COMMA: (",") >
|  < EQUALS: ("==") >
|  < NOTEQUALS: ("!=") >
|  < STREQUALS: ("equals" | "EQUALS") >
|  < STRCONTAINS: ("contains" | "CONTAINS") >
|  < STRCAT: ("|") >
|  < GREATERTHAN: (">") >
|  < LESSTHAN: ("<") >
|  < GREATERTHANEQ: (">=") >
|  < LESSTHANEQ: ("<=") >
|  < DEF: ("DEF" | "def") >
|  < DO: ("DO" | "do") >
|  < WHEN: ("WHEN" | "when") >
|  < SET: ("set" | "SET") >
|  < TO: ("to" | "TO") >
|  < MERGE: ("merge" | "MERGE") >
|  < INTO: ("into" | "INTO") >
|  < ANNO_DESCRIPTION: ("@description" | "@Description" | "@DESCRIPTION") >
|  < RULESET: ("ruleset" | "RULESET") >
|  < RULE: ("rule" | "Rule" | "RULE") >
|  < SWITCH: ("switch" | "SWITCH") >
|  < CASE: ("case" | "CASE") >
|  < EVENT: ("event" | "EVENT") >
|  < TIMER: ("timer" | "TIMER") >
|  < DEFCASE: ("default" | "DEFAULT") >
|  < CONDITION: ("condition" | "CONDITION") >
|  < CHANGES: ("changes" | "CHANGES") >
|  < RETURNS: ("returns" | "RETURNS") >
|  < RETURN: ("return" | "RETURN") >
|  < RESULT: ("Result") >
|  < TRUE: ("true" | "TRUE") >
|  < FALSE: ("false" | "FALSE") >
|  < REFERENCE: ("Reference") >
|  < VARIABLE: ("variable" | "VARIABLE") >
|  < START: ("start" | "START") >
|  < DURABLE: ("durable" | "DURABLE") >
|  < DYNAMIC: ("dynamic" | "DYNAMIC") >
|  < MACRO: ("macro" | "MACRO") >
|  < AS: ("as" | "AS") >
|  < ON: ("on" | "ON") >
|  < BEFORE: ("before" | "BEFORE") >
|  < AFTER: ("after" | "AFTER") >
|  < FOREACH: ("foreach" | "FOREACH") >
|  < IF: ("if" | "IF") >
|  < IN: ("in" | "IN") >
|  < ELSE: ("else" | "ELSE") >
|  < ELSEIF: ("elseif" | "ELSEIF") >
|  < WHILE: ("while" | "WHILE") >
|  < BREAK: ("break" | "BREAK") >
|  < ERROR: ("error" | "ERROR") >
|  < ASSERT: ("assert" | "ASSERT") >
|  < METHODSEP: (":") >
|  < VALUESEP: ("::") >
|  < SEMICOLON: (";") >
|  < NAMESPACESEP: ("$") >
|  < IS: ("is" | "IS" | "are" | "ARE") >
|  < AND: ("and" | "AND") >
|  < OR: ("or" | "OR") >
|  < NOT: ("not" | "NOT") >
|  < WAIT: ("wait" | "WAIT") >
|  < UNTIL: ("until" | "UNTIL") >
|  < ARRAY: ("Array") >
|  < TABLE: ("Table") >
|  < INTEGER: ("Integer") >
|  < DOUBLE: ("Double") >
|  < BOOLEAN: ("Boolean") >
|  < STRING: ("String") >
|  < DATE: ("Date") >
|  < EXTENSION: ("Extension") >
|  < PRINT: ("print" | "PRINT") >
|  < NEWLINE: ("newLine") >
|  < STRINGLITERAL: "\"" ( ~["\""] )* "\"" >
|  < name: (["a"-"z","A"-"Z","@","_","."]) (["a"-"z","A"-"Z",".","_","@","?","&","0"-"9","\\"])* >
|  < INTEGERLITERAL: ("-")? (["0"-"9"])+ >
|  < DATELITERAL: (<INTEGERLITERAL> "/" <INTEGERLITERAL> "/" <INTEGERLITERAL>)  >
|  < FLOATLITERAL: (["0"-"9"])+ "." (["0"-"9"])+ >
}

TOKEN :
{
   < UNKNOWN: ("#" | "^" | "?") >
}

void parseRuleSet(RuleSet ruleSet) :
{
    Token t;
    Rule rule;
}
{
    try {
        (rule = parseRule(ruleSet)
        {
            try
            {
                ruleSet.addRule(rule);
            }
            catch (Exception rce)
            {
                throw new ParseException(rce.getMessage());
            }
        }
        )+
    } catch (Throwable e) {
        ParseException pe = new ParseException(e.getMessage());
        pe.setToken(getToken(0));
        recover(pe, 0);
    }

}

Rule parseRule(RuleSet ruleSet) :
{
    Rule theRule = new Rule(ruleSet);
    Token t;
    boolean ruleSetDeclared = false;
}
{
    { ruleCount++; }
    (
        <RULESET> t = <name>
        {
            ruleSetName = t.image;
            ruleSetDeclared = true;
        }
    )?
    {
            if (ruleCount == 1 && !ruleSetDeclared) {
                ParseException pe = new ParseException("You must declare a ruleset before the first rule definition.");
                pe.setToken(getToken(1));
                recover(pe, WHITESPACE);
            }
    }
    rule(theRule)
    {
        return theRule;
    }
}

void rule(Rule theRule) :
{
    String desc = null;
    Token t;
    RuleVariable returnVariable = new StringVariable("#return") ;
}
{
  (
      <ANNO_DESCRIPTION> desc = stringValue()
      {
          theRule.setDescription(desc);
      }
  )?
  (
      returnVariable = returnType()
  )?
  {
      theRule.setReturnValue(returnVariable);
  }
  ruleName(theRule)
  <LPAREN> (ruleParams(theRule))? <RPAREN>
  <LBRACE>
  (<WHEN> <METHODSEP> whenClauses(theRule))?
  doClauses(theRule, theRule.getQueue())
  (<ON> <ERROR> <METHODSEP> doClauses(theRule, theRule.getErrorQueue()))?
  <RBRACE>
}

RuleVariable returnType() :
{
    RuleVariable rv = null;
}
{
    <STRING> { return new StringVariable("#return"); }
    |
    <DOUBLE> { return new DoubleVariable("#return"); }
    |
    <BOOLEAN> { return new BooleanVariable("#return"); }
    |
    <INTEGER> { return new IntegerVariable("#return"); }
    |
    <RESULT> { return new ResultVariable("#return"); }
    |
    <DATE> { return new DateVariable("#return"); }
    |
    <ARRAY> { return new Array("#return"); }
    |
    <TABLE> { return new Table("#return"); }
    |
    <EXTENSION> { return new Extension("#return"); }
}

void ruleParams(Rule theRule) :
{}
{
   try {
        ruleParam(theRule) (<COMMA> ruleParam(theRule))*
   } catch (ParseException pe) {
        pe.setToken(getToken(0));
        recover(pe, RPAREN);
   }
}

void ruleParam(Rule theRule) :
{
    Token tname = null;
    RuleVariable param;
    ParameterPair pair = null;
}
{
    try {
        pair = parameter(tname)
        {
            param = pair.var;
            try
            {
                theRule.getQueue().addParameter(param);
            }
            catch (RuleCreationException e)
            {
                Token tt = getToken(0);
                StringBuffer buf = new StringBuffer(e.getMessage());
                buf.append("\nRule: " + theRule.getName() + " at Line " + tt.beginLine + " Column " + token.beginColumn);
                throw new ParseException(buf.toString());
            }
        }
    } catch (ParseException pe) {
        pe.setToken(getToken(0));
        throw pe;
    }
}

ParameterPair parameter(Token t) :
{
    Token defaultToken = null;
    String defaultValue = null;
    ParameterPair pair = new ParameterPair();
}
{
    <STRING> t = variablename() (LOOKAHEAD(2) defaultValue = stringValue())?
    { 
        StringVariable sv = new StringVariable(t.image);
        if (defaultValue != null) {
            sv.setParameterDefaultValue(defaultValue);
        }
        pair.var = sv;
        pair.token = t;
        return pair; 
    }
    |
    <DOUBLE> t = variablename() (LOOKAHEAD(2) (defaultToken = doubleValue() | defaultToken = integerValue()))?
    { 
        DoubleVariable dv = new DoubleVariable(t.image);
        if (defaultToken != null) {
            dv.setParameterDefaultValue(defaultToken.image);
        }
        pair.var = dv;
        pair.token = t;
        return pair; 
    }
    |
    <INTEGER> t = variablename() (LOOKAHEAD(2) defaultToken = integerValue())?
    { 
        IntegerVariable iv = new IntegerVariable(t.image);
        if (defaultToken != null) {
            iv.setParameterDefaultValue(defaultToken.image);
        }
        pair.var = iv;
        pair.token = t;
        return pair; 
    }
    |
    <RESULT> t = variablename()
    { 
        ResultVariable resv = new ResultVariable(t.image);
        resv.setHasParameterDefault(false);
        pair.var = resv;
        pair.token = t;
        return pair; 
    }
    |
    <DATE> t = variablename() (LOOKAHEAD(2) defaultValue = stringValue())?
    { 
        DateVariable dtv = new DateVariable(t.image);
        if (defaultToken != null) {
            dtv.setParameterDefaultValue(defaultToken.image);
        }
        pair.var = dtv;
        pair.token = t;
        return pair; 
    }
    |
    <BOOLEAN> t = variablename() (LOOKAHEAD(2) defaultToken = booleanValue())?
    { 
        BooleanVariable bv = new BooleanVariable(t.image);
        if (defaultToken != null) {
            bv.setParameterDefaultValue(defaultToken.image);
        }
        pair.var = bv;
        pair.token = t;
        return pair; 
    }
    |
    <ARRAY> t = variablename()
    { 
        Array array = new Array(t.image);
        array.setHasParameterDefault(false);
        pair.var = array;
        pair.token = t;
        return pair; 
    }
    |
    <TABLE> t = variablename()
    { 
        Table table = new Table(t.image);
        table.setHasParameterDefault(false);
        pair.var = table;
        pair.token = t;
        return pair; 
    }
    |
    <EXTENSION> t = variablename()
    { 
        Extension ext = new Extension(t.image); 
        pair.var = ext;
        pair.token = t;
        return pair; 
    }
    |
    <REFERENCE> t = variablename()
    { 
        ReferenceVariable refv = new ReferenceVariable(t.image);
        refv.setHasParameterDefault(false);
        pair.var = refv;
        pair.token = t;
        return pair; 
    }
    |
    t = <name>
    { 
        ParseException pe = new ParseException("Invalid Variable Type: " + t.image +
            " at Line " + t.beginLine + " Column " + t.beginColumn);
        pe.setToken(t);
        throw pe;
    }
}

Token variablename() :
{
    Token t;
}
{
    t = <name>
    {
        return t;
    }
}

void doClauses(Rule theRule, InstructionQueue queue) :
{}
{
   (LOOKAHEAD(2)
       try {
           doClause(theRule, queue)
       } catch (ParseException pe) {
           pe.setToken(getToken(0));
           recover(pe, pe.currentToken.next.kind, 1);
       }
   )*
}

void doClause(Rule theRule, InstructionQueue queue) :
{
	Token t = null;
}
{
   try {
    LOOKAHEAD(3) nullObjectOperation(queue) <SEMICOLON>
    |
    defineVariableClause(queue)
    |
    returnClause(theRule, queue)
    |
    errorClause(theRule, queue) <SEMICOLON>
    |
    assertClause(theRule, queue)
    |
    LOOKAHEAD(3) setVariableClause(queue)
    |
    switchClause(theRule, queue)
    |
    ifClause(theRule, queue)
    |
    forEachClause(theRule, queue)
    |
    whileClause(theRule, queue)
    |
    LOOKAHEAD(3) breakClause(queue)
    |
    printClause(queue)
    |
    mergeResultsClause(queue)
    |
    LOOKAHEAD(2) valueExpression(queue) <SEMICOLON>
    |
    t = <name>
    { 
        ParseException pe = new ParseException("Unknown Variable or Keyword " + t.image + " at Line " + t.beginLine + " Column " + t.beginColumn);
        pe.setToken(t);
        throw pe;
    }
    |
    <SEMICOLON>
   } catch (ParseException pe) {
      if (pe.currentToken == null) {
          pe.setToken(token);
      }
      recover(pe, SEMICOLON);
   }

}

void nullObjectOperation(InstructionQueue queue) :
{
    IValue v;
}
{
    v = objectOperation(queue)
    {
        EvaluationInstruction ei = new EvaluationInstruction(v);
        ei.setLineNumber(token.beginLine);
        queue.addInstruction(ei);
    }
}

void mergeResultsClause(InstructionQueue queue) :
{
    IValue source;
    IValue target;
}
{
    try {
        <MERGE> source = valueExpression(queue) <INTO> target = valueExpression(queue)
        {
            try {
                if ( !(target instanceof ResultVariable) ) {
                    throw new RuleCreationException("Target of merge must be a Result."); 
                }

                ResultVariable rv = (ResultVariable)target;
                ObjectMethodExpression exp = new ObjectMethodExpression();
                exp.setObjectName(rv.getName(), queue); 
                exp.setMethodName("mergeWith"); 
                exp.addParameter(source);

                EvaluationInstruction ei = new EvaluationInstruction(exp);
                ei.setLineNumber(token.beginLine);
                queue.addInstruction(ei);
            } catch (RuleCreationException rce) {
                StringBuffer buffer = new StringBuffer(rce.getMessage());
                buffer.append(" at Line " + token.beginLine + " Column " + token.beginColumn);
                ParseException pe = new ParseException(buffer.toString());
                pe.setToken(token);
                throw pe;
            }
        }
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, SEMICOLON);
        return;
    }


    try {
        <SEMICOLON>
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, SEMICOLON);
    }
}

void printClause(InstructionQueue queue) :
{
    IValue v;
}
{
    try {
        <PRINT> v = valueExpression(queue)
        {
            PrintInstruction pi = new PrintInstruction(v);
            pi.setLineNumber(token.beginLine);
            queue.addInstruction(pi);
        }
    } catch (ParseException pe) {
        pe.setToken(token);
        recover(pe, SEMICOLON);
        return;
    }

    try {
        <SEMICOLON>
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, SEMICOLON);
    }
}

void returnClause(Rule theRule, InstructionQueue queue) :
{
    IValue v;
    Token t;
}
{
    <RETURN>
    (
        v = valueExpression(queue)
    )
    {
        ReturnInstruction ri = new ReturnInstruction();
        try
        {
            ri.setValue(theRule, v);
        }
        catch (RuleCreationException rce)
        {
            StringBuffer buffer = new StringBuffer(rce.getMessage());
            buffer.append(" at Line " + token.beginLine + " Column " + token.beginColumn);
            ParseException pe = new ParseException(buffer.toString());
            pe.setToken(token);
            throw pe;
        }
        ri.setLineNumber(token.beginLine);
        queue.addInstruction(ri);
    }

    try {
        <SEMICOLON>
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, SEMICOLON);
    }
}

void errorClause(Rule theRule, InstructionQueue queue) :
{
    IValue code = new IntegerVariable(null, 0);
    IValue desc = new StringVariable(null, "");
}
{
    <ERROR>
    (
        code = valueExpression(queue)
        (  <COMMA> desc = valueExpression(queue) )?
    )
    {
        ErrorInstruction ri = new ErrorInstruction();
        try
        {
            ri.setValue(theRule, desc);
            ri.setCode(code);
        }
        catch (RuleCreationException rce)
        {
            StringBuffer buffer = new StringBuffer(rce.getMessage());
            buffer.append(" at Line " + token.beginLine + " Column " + token.beginColumn);
            throw new ParseException(buffer.toString());
        }
        ri.setLineNumber(token.beginLine);
        queue.addInstruction(ri);
    }
}

void assertClause(Rule theRule, InstructionQueue queue) :
{
    IValue cond;
    IValue msg = new StringVariable(null, "Assertion Failed");
}
{
    <ASSERT>
    (
        cond = valueExpression(queue)
        (
            <METHODSEP> msg = valueExpression(queue)
        )?
    )
    {
        AssertInstruction ri = new AssertInstruction(theRule, cond, msg);
        ri.setLineNumber(token.beginLine);
        queue.addInstruction(ri);
    }

    try {
        <SEMICOLON>
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, SEMICOLON);
    }
}

void breakClause(InstructionQueue queue) :
{}
{
    <BREAK>
    {
        BreakInstruction bi = new BreakInstruction();
        bi.setLineNumber(token.beginLine);
        queue.addInstruction(bi);
    }

    try {
        <SEMICOLON>
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, SEMICOLON);
    }
}

void defineVariableClause(InstructionQueue queue) :
{
    RuleVariable var = null;
    SetInstruction si;
    IValue v = null;
    Token t = null;
    Token type = null;
    Token macroToken = null;
    boolean durable = false;
    boolean dynamic = false;
    boolean macro = false;
    boolean assignment = false;
}
{
    try {
        <DEF>
        ( 
            <DURABLE>
            { durable = true; }
        )?
        ( 
            <DYNAMIC>
            { dynamic = true; }
        )?
        ( 
            macroToken = <MACRO>
            { macro = true; }
        )?
        (
            try {
                <STRING> t = variablename()
                {
                    var = new StringVariable(t.image);
                }
                |
                <DOUBLE> t = variablename()
                {
                    var = new DoubleVariable(t.image);
                }
                |
                <INTEGER> t = variablename()
                {
                    var = new IntegerVariable(t.image);
                }
                |
                <RESULT> t = variablename()
                {
                    var = new ResultVariable(t.image);
                }
                |
                <DATE> t = variablename()
                {
                    var = new DateVariable(t.image);
                }
                |
                <BOOLEAN> t = variablename()
                {
                    var = new BooleanVariable(t.image);
                }
                |
                <ARRAY> <LPAREN> (v = valueExpression(queue))? <RPAREN> t = variablename()
                {
                    var = new Array(t.image);
                    CreateArrayInstruction cai = new CreateArrayInstruction(t.image, v);
                    cai.setLineNumber(token.beginLine);
                    queue.addInstruction(cai);
                }
                |
                <TABLE> t = variablename()
                {
                    var = new Table(t.image);
                    CreateTableInstruction cti = new CreateTableInstruction(t.image);
                    cti.setLineNumber(token.beginLine);
                    queue.addInstruction(cti);
                }
                |
                <RULE> t = variablename()
                {
                    var = new RuleAccessor(t.image, queue);
                }
                |
                <REFERENCE> t = variablename()
                {
                    var = new ReferenceVariable(t.image);
                }
                |
                <EXTENSION> t = variablename()
                {
                    var = new Extension(t.image);
                }
                |
                t = <name>
                { 
                    ParseException pe = new ParseException("Invalid Variable Type: " + t.image +
                        " at Line " + t.beginLine + " Column " + t.beginColumn);
                    pe.setToken(t);
                    throw pe;
                }
            } catch (ParseException pe) {
                pe.setToken(getToken(1));
                throw pe;
            }
        )
        {
            var.setDurable(durable);
            var.setDynamic(dynamic);
            try {
                queue.addVariable(var);
            }
            catch (RuleCreationException e)
            {
                StringBuffer buf = new StringBuffer(e.getMessage());
                buf.append(" Line " + t.beginLine + " Column " + t.beginColumn);
                ParseException pe = new ParseException(buf.toString());
                pe.setToken(t);
                throw pe;
            }

            try {
                var.setMacro(macro);
            }
            catch (RuleCreationException e)
            {
                StringBuffer buf = new StringBuffer(e.getMessage());
                buf.append(" Line " + macroToken.beginLine + " Column " + macroToken.beginColumn);
                ParseException pe = new ParseException(buf.toString());
                pe.setToken(macroToken);
                throw pe;
            }
        }
    } catch (ParseException pe) {
        pe.setToken(token);
        recover(pe, SEMICOLON);
        return;
    }

    try {
        (
            <ASSIGNMENT>
            {
                assignment = true;
                si = new SetInstruction();
                si.addVariable(var);
            }
            v = valueExpression(queue)
            {
                si.setValue(v);
                si.setLineNumber(token.beginLine);
                queue.addInstruction(si);
            }
        )?
    } catch (ParseException pe) {
        pe.setToken(getToken(0));
        if (assignment) {
            pe.setToken(getToken(1));
        }
        recover(pe, SEMICOLON);
        return;
    }

    try {
        <SEMICOLON>
    } catch (ParseException pe) {
        pe.setToken(getToken(0));
        if (!assignment) {
            pe.setToken(getToken(1));
        }
        recover(pe, SEMICOLON);
    }
}

void switchClause(Rule theRule, InstructionQueue queue) :
{
    SwitchInstruction inst = new SwitchInstruction(queue);
    IValue v;
    String s;
    int _firstLine;
}
{
    <SWITCH>
    { _firstLine = token.beginLine; }
    (<STRING> { inst.setStringMatching(true); } )?
    <LPAREN>
    v = valueExpression(queue) { inst.setValue(v); }
    <RPAREN>
    <LBRACE>
    (
      <CASE>
      {
         InstructionQueue q = new InstructionQueue();
         q.setParent(queue);
      }
      s = constant() <METHODSEP>
      doClauses(theRule, q)
      {
         inst.addCase(s, q);
      }
    )+
    (
      <DEFCASE> <METHODSEP>
      {
         InstructionQueue q = new InstructionQueue();
         q.setParent(queue);
      }
      doClauses(theRule, q) { inst.setDefaultCase(q); }
    )?
    <RBRACE>
    {
        inst.setLineNumber(_firstLine);
        queue.addInstruction(inst);
    }
}

void forEachClause(Rule theRule, InstructionQueue queue) :
{
    IValue startValue;
    IValue endValue;
    ForEachInstruction fei = new ForEachInstruction(queue);
    Token t;
}
{
    try {
        <FOREACH> <LPAREN> t = variablename() <IN> startValue = valueExpression(queue) <TO> endValue = valueExpression(queue) <RPAREN>
        {
            fei.getBlock().setParent(queue);
            IntegerVariable index = new IntegerVariable(t.image, startValue.valueAsInteger());
            index.setDurable(true);
            index.setUserMutable(false);

            try {
                    fei.setIndexVariable(index);
            } catch (RuleCreationException e) {
                Token tt = getToken(0);
                StringBuffer buf = new StringBuffer(e.getMessage());
                buf.append(" at Line " + tt.beginLine + " Column " + token.beginColumn);
                throw new ParseException(buf.toString());
            }

            fei.setIndexStartValue(startValue);
            fei.setIndexEndValue(endValue);
            fei.setLineNumber(token.beginLine);
            queue.addInstruction(fei);
        }
        <LBRACE>
        doClauses(theRule, fei.getBlock())
        <RBRACE>
    } catch (ParseException pe) {
        if (!pe.isSetToken()) {
            pe.currentToken = getToken(1);
        }
        recover(pe, RBRACE);
    }

}

void whileClause(Rule theRule, InstructionQueue queue) :
{
    IValue condition;
    WhileInstruction wi;
}
{
    try {
        <WHILE> <LPAREN> condition = valueExpression(queue) <RPAREN>
        {
            wi = new WhileInstruction(queue);
            wi.getBlock().setParent(queue);
            wi.setCondition(condition);
            wi.setLineNumber(token.beginLine);
            queue.addInstruction(wi);
        }
        <LBRACE>
        doClauses(theRule, wi.getBlock())
        <RBRACE>
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, RBRACE);
    }
}

void ifClause(Rule theRule, InstructionQueue queue) :
{
    IValue condition;
    IfInstruction ii = new IfInstruction(queue);
    InstructionQueue q;
}
{
    try {
        <IF> <LPAREN> condition = valueExpression(queue) <RPAREN>
        {
            ii.setCondition(condition);
            ii.setLineNumber(token.beginLine);
            queue.addInstruction(ii);
            ii.getIfBlock().setParent(queue);
        }
        <LBRACE>
        doClauses(theRule, ii.getIfBlock())
        <RBRACE>
        (
        LOOKAHEAD(2) <ELSE> <IF> <LPAREN> condition = valueExpression(queue) <RPAREN>
        <LBRACE>
        {
            q = ii.addElseIfBlock(condition);
            q.setParent(queue);
        }
        doClauses(theRule, q)
        <RBRACE>
        )*
        (
        <ELSE> <LBRACE>
        { ii.getElseBlock().setParent(queue); }
        doClauses(theRule, ii.getElseBlock())
        <RBRACE>
        )?
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, RBRACE);
    }
}

void setVariableClause(InstructionQueue queue) :
{
    SetInstruction instr = new SetInstruction();
    IValue v;
}
{
    try {
      (
        (
            setvariables(queue, instr)
            <ASSIGNMENT>
            v = valueExpression(queue)
            {
                instr.setValue(v);
            }
        )
        |
        (
            <SET> <TO>
            v = valueExpression(queue)
            {
                instr.setValue(v);
            }
            <METHODSEP> setvariables(queue, instr)
        )
      )
      {
          instr.setLineNumber(token.beginLine);
          queue.addInstruction(instr);
      }
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, RBRACE);
    }
    
    try {
        <SEMICOLON>
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, SEMICOLON);
    }
}

void setvariables(InstructionQueue queue, SetInstruction instr) :
{}
{
   setvariable(queue, instr) (<COMMA> setvariable(queue, instr))*
}

void setvariable(InstructionQueue queue, SetInstruction instr) :
{
    Token t;
    IValue v = null;
    IValue v2 = null;
    boolean isArray = false;
    boolean isTable = false;
}
{
    t = <name>
    (
        LOOKAHEAD(3)
        (
            <LBRACKET> v = valueExpression(queue) <RBRACKET>
            {
               isArray = true;
            }
        )
        |
        (
            <LBRACKET> v = valueExpression(queue) <COMMA> v2 = valueExpression(queue) <RBRACKET>
            {
               isTable = true;
            }
        )
    )?
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            ParseException pe = new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
            pe.setToken(t);
            throw pe;
        }

        if (isArray)
        {
            if (!rv.isArray())
            {
                ParseException pe = new ParseException("Attempt to index non array variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
                pe.setToken(t);
                throw pe;
            }
            rv = new ArrayIndexer(queue, (Array)rv, v);
        }
        else if (isTable)
        {
            if (!rv.isTable())
            {
                ParseException pe = new ParseException("Attempt to index non table variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
                pe.setToken(t);
                throw pe;
            }
            rv = new TableIndexer(queue, (Table)rv, v, v2);
        }

        instr.addVariable(rv);
    }
}

IValue valueExpression(InstructionQueue queue) :
{
    ValueExpression exp = new ValueExpression();
    IValue v;
    IValue left = null;
    IValue right = null;
    ValueExpression.Operator operator = ValueExpression.Operator.INVALID;
}
{
    try {
        (
        left = valueOperand(queue) 
        {
            exp.setOperand(true, left);
        }
        ( LOOKAHEAD(2) 
            operator = valueOperator() right = valueOperand(queue)
            {
                exp.setOperator(operator, right);
            }
        )*
        |
        <NOT> left = valueOperand(queue)
        {
            exp.setOperand(true, left);
            exp.setOperator(ValueExpression.Operator.NOT, left);
        }
        )
        {
            if (exp.getRightOperand() == null)
            {
                return exp.getLeftOperand();
            }
            else
            {
                return exp;
            }
        }
    } catch (ParseException pe) {
        if (pe.currentToken == null) {
            pe.setToken(getToken(1));
        }
        //recover(pe, SEMICOLON);
        throw pe;
    }
}

Token booleanValue() :
{
    Token t;
}
{
    t = <TRUE>
    {
       return t;
    }
    |
    t = <FALSE>
    {
       return t;
    }
}


Token doubleValue() :
{
    Token t;
}
{
    t = <FLOATLITERAL>
    {
       return t;
    }
}

Token integerValue() :
{
    Token t;
}
{
    t = <INTEGERLITERAL>
    {
       return t;
    }
}

String stringValue() :
{
    Token token;
    String t;
}
{
    (
        ( token = <STRINGLITERAL>
            {
                t = token.image;
                t = t.substring(1, t.length() - 1);
            }
        )
        |
        ( <NEWLINE>
        t = getNewLine()
        )
    )
    {
       return t;
    }
}

void whenClauses(Rule theRule) :
{}
{
   (
      conditionClause(theRule)
   )+
}

void conditionClause(Rule theRule) :
{
    IValue v;
}
{
   <CONDITION> v = valueExpression(theRule.getQueue()) <SEMICOLON>
   {
      theRule.addCondition(v);
   }
}

void ruleName(Rule theRule) :
{
  Token t = null;
}
{
    try {
        t = <name>
        {
            theRule.setName(ruleSetName + "$" + t.image);
        }
    } catch (ParseException pe) {
        pe.setToken(getToken(1));
        recover(pe, EOF);
    }
}

ValueExpression.Operator valueOperator() :
{
}
{
    <PLUS>  { return ValueExpression.Operator.PLUS; }
    |
    <MINUS> { return ValueExpression.Operator.MINUS; }
    |
    <MULT> { return ValueExpression.Operator.MULT; }
    |
    <DIV> {  return ValueExpression.Operator.DIV; }
    |
    <STRCAT> { return ValueExpression.Operator.STRCAT; }
    |
    <EQUALS> { return ValueExpression.Operator.VALEQUALS; }
    |
    <STREQUALS> { return ValueExpression.Operator.STREQUALS; }
    |
    <NOTEQUALS> { return ValueExpression.Operator.NOTEQUALS; }
    |
    <NOT> <STREQUALS> {  return ValueExpression.Operator.STRNOTEQUALS; }
    |
    <GREATERTHAN> { return ValueExpression.Operator.GREATERTHAN; }
    |
    <LESSTHAN> { return ValueExpression.Operator.LESSTHAN; }
    |
    <GREATERTHANEQ> {  return ValueExpression.Operator.GREATERTHANEQ; }
    |
    <LESSTHANEQ> {  return ValueExpression.Operator.LESSTHANEQ; }
    |
    <AND> { return ValueExpression.Operator.AND; }
    |
    <OR> { return ValueExpression.Operator.OR;}
    |
    <IS> { return ValueExpression.Operator.BOOLEQUALS; }
}

IValue valueOperand(InstructionQueue queue) :
{
    Token t;
    IValue v = null;
    IValue v2 = null;
    String s;
    boolean b;
    boolean isArray = false;
    boolean isTable = false;
}
{
    t = doubleValue()
    { return new DoubleVariable(null, t.image); }
    |
    t = integerValue()
    { return new IntegerVariable(null, t.image); }
    |
    <TRUE>
    { return new BooleanVariable(null, true); }
    |
    <FALSE>
    { return new BooleanVariable(null, false); }
    |
    s = stringValue()
    { return new StringVariable(null, s); }
    |
    v = arrayValue(queue)
    { return v; }
    |
    v = referenceValue(queue)
    { return v; }
    |
    LOOKAHEAD(2) v = objectOperation(queue)
    { return v; }
    |
    LOOKAHEAD(2) v = objectDataValue(queue)
    { return v; }
    |
    LOOKAHEAD(2) t = <name>
    (
        LOOKAHEAD(3)
        (
            <LBRACKET> v = valueExpression(queue) <RBRACKET>
            {
               isArray = true;
            }
        )
        |
        (
            <LBRACKET> v = valueExpression(queue) <COMMA> v2 = valueExpression(queue) <RBRACKET>
            {
               isTable = true;
            }
        )
    )?
    {
        RuleVariable rv = queue.getVariable(t.image);
        if (rv == null)
        {
            ParseException pe = new ParseException("Reference to undefined variable: " + t.image
              + " at Line " + t.beginLine + " Column " + t.beginColumn);
            pe.setToken(t);
            throw pe;
        }

        if (isArray)
        {
            if (!rv.isArray())
            {
                ParseException pe = new ParseException("Attempt to index non array variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
                pe.setToken(t);
                throw pe;
            }
            rv = new ArrayIndexer(queue, (Array)rv, v);
        }
        else if (isTable)
        {
            if (!rv.isTable())
            {
                ParseException pe = new ParseException("Attempt to index non table variable: " + t.image
                  + " at Line " + t.beginLine + " Column " + t.beginColumn);
                pe.setToken(t);
                throw pe;
            }
            rv = new TableIndexer(queue, (Table)rv, v, v2);
        }

        v = rv;
    }
    { return v; }
    |
    LOOKAHEAD(3) <LPAREN>
    v = valueExpression(queue)
    <RPAREN>
    { return v; }
    
}

IValue referenceValue(InstructionQueue queue) :
{
    ReferenceVariable ref = new ReferenceVariable(null);
    IValue v;
}
{
    <LBRACE>
    v = valueExpression(queue)
    <RBRACE>
    {
        ref.setRuntime(queue.getRuleSet().getRuntime());
        ref.setValue(v, true);
        return ref;
    }
}

IValue arrayValue(InstructionQueue queue) :
{
    Array array = new Array(null);
    IValue v;
    Vector vector = new Vector();
}
{
    <LBRACKET>
    (
       v = valueExpression(queue) { vector.add(v); }
       (<COMMA>
          v = valueExpression(queue) { vector.add(v); }
       )*
    )?
    <RBRACKET>
    {
        array.initialize(vector);
        return array;
    }
}

IValue objectOperation(InstructionQueue queue) :
{
    IValue v;
}
{
    (
        v = directObjectOperation(queue)
    )
    {
        return v;
    }
}

IValue objectDataValue(InstructionQueue queue) :
{
    ObjectMethodExpression exp = new ObjectMethodExpression();
    Token nameToken;
    Token nameSpaceToken = null;
    Token t;
    IValue val;
}
{
    ( LOOKAHEAD(2)
       nameSpaceToken = <name> <NAMESPACESEP>
    )?
    nameToken = <name>
    { 
        String qualifier;
        String nm = nameToken.image;
        if (nameSpaceToken != null) {
            nm = nameSpaceToken.image + "$" + nm;
        } else {
            nm = ruleSetName + "$" + nm;
        }
         
        exp.setObjectName(nm, queue); 
    }
    <VALUESEP>
    t = <name>
    { 
        exp.setMethodName("valueOf", true); 
        exp.addParameter(new StringVariable(null, t.image));
        
        try {
            exp.validateParameters();
        } catch (ScriptExecutionException s) {
            //throw new ParseException(s + " at Line " + t.beginLine + " Column " + t.beginColumn);
            ParseException pe = new ParseException(s.getMessage() + " at Line " + t.beginLine + " Column " + t.beginColumn);
            pe.setToken(t);
            throw pe;
        }
        return exp;
        
    }
}

IValue directObjectOperation(InstructionQueue queue) :
{
    ObjectMethodExpression exp = new ObjectMethodExpression();
    Token nameToken;
    Token nameSpaceToken = null;
    Token t2 = null;
    IValue val;
    boolean useInvoke = true;
}
{
    ( LOOKAHEAD(2)
       nameSpaceToken = <name> <NAMESPACESEP>
    )?
    nameToken = <name>
    (
        <METHODSEP>
        t2 = <name>
        { 
            useInvoke = false; 
        }
    )?
    <LPAREN>
    { 
        String nm = nameToken.image;
        if (useInvoke) {
            if (nameSpaceToken != null) {
                nm = nameSpaceToken.image + "$" + nm;
            } else {
                nm = ruleSetName + "$" + nm;
            }
        } 

        exp.setObjectName(nm, queue); 

        if (useInvoke) {
            exp.setMethodName("invoke");
        } else {
            exp.setMethodName(t2.image); 
        }
    }
    (
        (
           val = valueExpression(queue)
        )
        { exp.addParameter(val); }
        (
            <COMMA>
            (
                val = valueExpression(queue)
            )
            { exp.addParameter(val); }
        )*
    )?
    <RPAREN>
    {
        try {
            exp.validateParameters();
        } catch (ScriptExecutionException s) {
            //throw new ParseException(s + " at Line " + t2.beginLine + " Column " + t2.beginColumn);
            ParseException pe = new ParseException(s.getMessage() + " at Line " + t2.beginLine + " Column " + t2.beginColumn);
            pe.setToken(t2);
            throw pe;
        }

        return exp;
    }
}

String constant() :
{
    Token t;
    String s;
}
{
    t = doubleValue() { return t.image; }
    |
    t = integerValue() { return t.image; }
    |
    s = stringValue() { return s; }
    |
    t = booleanValue() { return t.image; }
}

JAVACODE

String grabToCharacter(char grab)
{
   StringBuffer buffer = new StringBuffer();
   JavaCharStream s = this.token_source.input_stream;

   try
   {
       char cc = s.readChar();
       while (cc != grab)
       {
          if (cc == '\\')
          {
             // get the next character too
             cc = s.readChar();
             if (cc == 'n')
             {
                buffer.append("\n");
             }
             else if (cc == 't')
             {
                buffer.append("\t");
             }
             else 
             {
                buffer.append(cc);
             }
          }
          else
          {
              buffer.append(cc);
          }
          cc = s.readChar();
       }
   }
   catch (java.io.IOException e)
   {
      throw new RuntimeException(e.getMessage());
   }
   return buffer.toString();
}

JAVACODE

String getNewLine()
{
    return "\n";
}

